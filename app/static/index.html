<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Upload SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
    <button onclick="showCacheKeys()">Show Cache Keys</button>
    <button id="deletePickBtn" onclick="deleteSelectedPick()" disabled>Delete Pick</button>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script src="/static/pako.min.js"></script>
  <script src="/static/msgpack.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let savedXRange = null;
    let savedYRange = null;
    let latestSeismicData = null;
    const defaultDt = 0.004;
    const PREFETCH_WIDTH = 3;   // ±10
    const FALLBACK_MAX = 8;  // API 無い場合
    const HARD_LIMIT_BYTES = 1000 * 1024 * 1024; // 800MB

    const cache = new Map(); // key -> {scale, buf:Int8Array}
    const inflight = new Map();
    let sectionShape = null;
    let renderedStart = null;
    let renderedEnd = null;
    let picks = [];
    let downsampleFactor = 1;
    let selectedPickIndex = null;

    function showCacheKeys() {
        const currentKeys = Array.from(cache.keys());
        console.log('Cache keys:', currentKeys);
      }

  function toFloat32(buf, scale) {
    return Float32Array.from(buf, v => v / scale);
  }
  function putCache(key, scale, buf) {
    const f32 = Float32Array.from(buf, v => v / scale);
    cache.set(key, { scale, buf, f32 });
    //cache.set(key, { scale, buf });

    const canCheckMemory =
      performance.memory &&
      performance.memory.usedJSHeapSize > 0;

    const used = canCheckMemory ? performance.memory.usedJSHeapSize : 0;

    console.log('--- putCache called ---');
    console.log('Added key:', cache.keys());
    console.log('Cache size:', cache.size);
    if (canCheckMemory) {
      const total = performance.memory.totalJSHeapSize;
      const ratio = used / total;
      console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB`);

    } else {
      console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB (fallback, no total)`);
    }

    if (used > HARD_LIMIT_BYTES) {
      console.warn(`⚠ Memory limit exceeded! (${(used / 1024 / 1024).toFixed(1)} MB > 800 MB)`);
      let removed = 0;
      while (cache.size > 1) {
        const removedKey = cache.keys().next().value;
        const entry = cache.get(removedKey);

        // 🔽 メモリ解放を促すために参照を切る
        if (entry) {
          entry.f32 = null;
          entry.buf = null;
        }

        cache.delete(removedKey);
        removed++;
      }
      console.warn(`Evicted ${removed} items due to hard heap limit.`);
      console.log('Remaining keys:', Array.from(cache.keys()));
    }

    console.log('------------------------');
  }
    function getCacheF32(key) {
      if (!cache.has(key)) return null;
      const entry = cache.get(key);
      cache.delete(key); cache.set(key, entry); // refresh LRU
      return entry.f32;
    }

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

      async function fetchKey1Values() {
        const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
        if (res.ok) {
          const data = await res.json();
          key1Values = data.values;
          setKey1SliderMax(key1Values.length - 1);
          document.getElementById('key1_idx_display').min = key1Values[0];
          document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
          document.getElementById('key1_idx_slider').value = 0;
          updateKey1Display();
        }
      }

      function prefetchAround(centerIdx) {
        for (const ctrl of inflight.values()) ctrl.abort();
        inflight.clear();
        const start = Math.max(0, centerIdx - PREFETCH_WIDTH);
        const end = Math.min(key1Values.length - 1, centerIdx + PREFETCH_WIDTH);
        const scheduler = cb => {
          if ('requestIdleCallback' in window) {
            requestIdleCallback(cb);
          } else {
            setTimeout(cb, 0);
          }
        };
        for (let i = start; i <= end; i++) {
          if (i === centerIdx) continue;
          const key = key1Values[i];
          if (cache.has(key) || inflight.has(key)) continue;
          const controller = new AbortController();
          inflight.set(key, controller);
          scheduler(async () => {
            try {
              const url = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
              const res = await fetch(url, { signal: controller.signal });
              if (res.ok) {
                const bin = new Uint8Array(await res.arrayBuffer());
                const obj = msgpack.decode(bin);
                const int8 = new Int8Array(obj.data.buffer);
                putCache(key, obj.scale, int8);
                if (!sectionShape) sectionShape = obj.shape;
              }
            } catch (err) {
              if (err.name !== 'AbortError') {
                console.warn('Prefetch failed', key, err);
              }
            } finally {
              inflight.delete(key);
            }
          });
        }
      }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchPicks();
        await fetchAndPlot();
      }
    }

  async function fetchPicks() {
    if (!currentFileId) return;
    try {
      const res = await fetch(`/picks?file_id=${currentFileId}`);
      if (res.ok) {
        const data = await res.json();
        picks = data.picks || [];
      }
    } catch (e) {
      console.error('Failed to fetch picks', e);
    }
  }

  async function postPick(trace, time) {
    try {
      await fetch('/picks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_id: currentFileId, trace, time })
      });
    } catch (e) {
      console.error('Failed to post pick', e);
    }
  }

  async function deletePick(trace) {
    try {
      await fetch(`/picks?file_id=${currentFileId}&trace=${trace}`, { method: 'DELETE' });
    } catch (e) {
      console.error('Failed to delete pick', e);
    }
  }

  async function fetchAndPlot() {
    console.log('--- fetchAndPlot start ---');
    console.time('Total fetchAndPlot');

    const index = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[index];

    console.time('Cache lookup');
    let f32 = getCacheF32(key1Val);
    console.timeEnd('Cache lookup');

    let traces;

    if (f32) {
      console.time('Decode from cache');
      const [nTraces, nSamples] = sectionShape;
      traces = new Array(nTraces);
      for (let i = 0; i < nTraces; i++) {
        traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
      }
      console.timeEnd('Decode from cache');
      latestSeismicData = traces;
    } else {
      console.time('Fetch binary');
      const urlBin = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
      const res = await fetch(urlBin);
      if (!res.ok) {
        alert('Failed to load section');
        return;
      }
      const bin = new Uint8Array(await res.arrayBuffer());
      console.timeEnd('Fetch binary');

      console.time('Decode & cache');
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      putCache(key1Val, obj.scale, int8);
      sectionShape = obj.shape;
      const tmp = toFloat32(int8, obj.scale);
      const [nTraces, nSamples] = sectionShape;
      traces = new Array(nTraces);
      for (let i = 0; i < nTraces; i++) {
        traces[i] = tmp.subarray(i * nSamples, (i + 1) * nSamples);
      }
      console.timeEnd('Decode & cache');
      latestSeismicData = traces;
    }

    console.time('Plotting');
    const [s, e] = savedXRange ? visibleTraceIndices(savedXRange, latestSeismicData.length) : [0, latestSeismicData.length - 1];
    plotSeismicData(latestSeismicData, defaultDt, s, e);
    console.timeEnd('Plotting');

    console.time('Prefetch');
    prefetchAround(index);
    console.timeEnd('Prefetch');

    console.timeEnd('Total fetchAndPlot');
    console.log('--- fetchAndPlot end ---');
  }

    function visibleTraceIndices(range, total) {
      let start = Math.floor(range[0]);
      let end = Math.ceil(range[1]);
      start = Math.max(0, start);
      end = Math.min(total - 1, end);
      return [start, end];
    }

    function plotSeismicData(seismic, dt, startTrace = 0, endTrace = seismic.length - 1) {
      const totalTraces = seismic.length;
      startTrace = Math.max(0, startTrace);
      endTrace = Math.min(totalTraces - 1, endTrace);
      const nTraces = endTrace - startTrace + 1;
      const nSamples = seismic[0].length;
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, totalTraces - 1];
      const visibleTraces = endTrace - startTrace + 1;
      const density = visibleTraces / widthPx;

      let traces = [];
      const gain = 1.0;

      if (density < 0.1) {
        downsampleFactor = 1;
        const time = new Float32Array(nSamples);
        for (let t = 0; t < nSamples; t++) {
          time[t] = t * dt;
        }
        for (let i = startTrace; i <= endTrace; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            const val = raw[j] * gain;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, showlegend: false });
        }
      } else {
        const MAX_POINTS = 3_000_000;
        let factor = 1;
        while (Math.floor(nTraces / factor) * Math.floor(nSamples / factor) > MAX_POINTS) {
          factor++;
        }

        const nTracesDS = Math.floor(nTraces / factor);
        const nSamplesDS = Math.floor(nSamples / factor);
        console.log('Downsampling factor:', factor);
        console.log('Final dimensions:', nTracesDS, 'x', nSamplesDS);

        const time = new Float32Array(nSamplesDS);
        for (let t = 0; t < nSamplesDS; t++) {
          time[t] = t * dt * factor;
        }

        const zData = Array.from({ length: nSamplesDS }, () => new Float32Array(nTracesDS));
        let zMin = Infinity;
        let zMax = -Infinity;
        for (let i = startTrace, col = 0; col < nTracesDS; i += factor, col++) {
          const trace = seismic[i];
          for (let j = 0, row = 0; row < nSamplesDS; j += factor, row++) {
            const val = trace[j];
            zData[row][col] = val;
            if (val < zMin) zMin = val;
            if (val > zMax) zMax = val;
          }
        }
        const xVals = new Float32Array(nTracesDS);
        for (let i = 0; i < nTracesDS; i++) xVals[i] = startTrace + i * factor;
        downsampleFactor = factor;
        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: 'Greys',
          zmin: zMin,
          zmax: zMax,
          showscale: false,
          hoverinfo: 'skip'
        }];
      }

      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          ...(savedXRange ? { range: savedXRange } : {})
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [nSamples * dt, 0]  // reversed を手動設定
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: false
      };
      layout.shapes = picks.map((p, i) => ({
        type: 'line',
        x0: p.trace - 0.4,
        x1: p.trace + 0.4,
        y0: p.time,
        y1: p.time,
        line: { color: i === selectedPickIndex ? 'blue' : 'red', width: 2 }
      }));

      Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: true,
        modeBarButtonsToAdd: ['eraseshape']
      });
      setTimeout(() => Plotly.Plots.resize(plotDiv), 50);
      renderedStart = startTrace;
      renderedEnd = endTrace;
      console.log(`Rendered traces ${startTrace}-${endTrace}`);

      plotDiv.removeAllListeners('plotly_relayout');
      plotDiv.removeAllListeners('plotly_click');
      plotDiv.on('plotly_relayout', handleRelayout);
      plotDiv.on('plotly_click', handlePlotClick);
    }

    function pickNear(trace, time) {
      return picks.findIndex(
        p => Math.abs(p.trace - trace) < 0.5 && Math.abs(p.time - time) < defaultDt * downsampleFactor * 2
      );
    }

    async function handlePlotClick(ev) {
      if (!ev.points.length) return;
      const point = ev.points[0];
      let trace = Math.round(point.x);
      let time = point.y;
      if (downsampleFactor > 1) {
        const dt = defaultDt * downsampleFactor;
        const idx = point.y / dt;
        const lower = Math.floor(idx);
        const frac = idx - lower;
        const lowerTime = lower * dt;
        const upperTime = (lower + 1) * dt;
        time = lowerTime + (upperTime - lowerTime) * frac;
      }
      const existing = pickNear(trace, time);
      if (existing >= 0) {
        selectedPickIndex = existing;
        document.getElementById('deletePickBtn').disabled = false;
      } else {
        selectedPickIndex = null;
        document.getElementById('deletePickBtn').disabled = true;
        picks.push({ trace, time });
        await postPick(trace, time);
      }
      plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
    }

    async function handleRelayout(ev) {
      const plotDiv = document.getElementById('plot');
      if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
        savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
      } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
        savedXRange = null;
        savedYRange = null;
      }

      if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
        const y0 = ev['yaxis.range[0]'];
        const y1 = ev['yaxis.range[1]'];
        savedYRange = y0 > y1 ? [y0, y1] : [y1, y0];
      }

      if (latestSeismicData) {
        const [s, e] = savedXRange
          ? visibleTraceIndices(savedXRange, latestSeismicData.length)
          : [0, latestSeismicData.length - 1];
        if (s !== renderedStart || e !== renderedEnd) {
          plotSeismicData(latestSeismicData, defaultDt, s, e);
        }
      }

      const shapeKey = Object.keys(ev).find(k => k.startsWith('shapes['));
      if (shapeKey) {
        const idx = parseInt(shapeKey.match(/shapes\[(\d+)\]/)[1], 10);
        const shape = plotDiv.layout.shapes[idx];
        const trace = (shape.x0 + shape.x1) / 2;
        const time = (shape.y0 + shape.y1) / 2;
        picks[idx] = { trace, time };
        await postPick(Math.round(trace), time);
      } else if (Array.isArray(ev.shapes)) {
        const newPicks = ev.shapes.map(s => ({ trace: (s.x0 + s.x1) / 2, time: (s.y0 + s.y1) / 2 }));
        const oldTraces = new Set(picks.map(p => Math.round(p.trace)));
        const newTraces = new Set(newPicks.map(p => Math.round(p.trace)));
        for (const t of oldTraces) {
          if (!newTraces.has(t)) {
            await deletePick(t);
          }
        }
        picks = newPicks;
        selectedPickIndex = null;
        document.getElementById('deletePickBtn').disabled = true;
      }
    }

    async function deleteSelectedPick() {
      if (selectedPickIndex === null) return;
      const trace = Math.round(picks[selectedPickIndex].trace);
      await deletePick(trace);
      picks.splice(selectedPickIndex, 1);
      selectedPickIndex = null;
      document.getElementById('deletePickBtn').disabled = true;
      plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
    }

    window.addEventListener('DOMContentLoaded', loadSettings);
  </script>
</body>
</html>
