<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Seismic Wiggle Viewer</title>
  <style>
    :root {
      color-scheme: light;
    }

    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #mainContent {
      flex: 1;
      display: flex;
      min-height: 0;
      background: #fff;
    }

    #viewerColumn {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
      display: flex;
      gap: 1em;
      align-items: center;
      flex-wrap: wrap;
      overflow-y: auto;
    }

    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }

    #plot {
      flex: 1;
      width: 100%;
      min-height: 0;
    }

    #pickModeBtn.active {
      background: #007bff;
      color: #fff;
    }

    #pipelinePanel {
      width: 320px;
      max-width: 100%;
      border-left: 1px solid #ddd;
      background: #fdfdfd;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .pipeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75em 1em;
      border-bottom: 1px solid #ddd;
      background: #f7f7f7;
      font-weight: 600;
    }

    .pipeline-header .pipeline-actions {
      display: inline-flex;
      gap: 0.5em;
      align-items: center;
    }

    .pipeline-add {
      position: relative;
      display: inline-flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .pipeline-add button {
      margin-right: 0;
    }

    .pipeline-add-menu {
      position: absolute;
      top: 100%;
      right: 0;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, .08);
      padding: .25em 0;
      margin-top: .3em;
      display: none;
      min-width: 160px;
      z-index: 20;
    }

    .pipeline-add-menu.open {
      display: block;
    }

    .pipeline-add-menu button {
      display: block;
      width: 100%;
      background: transparent;
      border: 0;
      text-align: left;
      padding: .45em 1em;
      font-size: .95em;
      cursor: pointer;
    }

    .pipeline-add-menu button:hover,
    .pipeline-add-menu button:focus {
      background: #eef3ff;
    }

    #pipelineCards {
      flex: 1;
      overflow-y: auto;
      padding: 1em;
      background: #fafafa;
    }

    .pipeline-card {
      border: 1px solid #d2d2d2;
      border-radius: 8px;
      padding: .75em;
      background: #fff;
      display: flex;
      flex-direction: column;
      gap: .5em;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .04);
    }

    .pipeline-card+.pipeline-card {
      margin-top: .75em;
    }

    .pipeline-card.disabled {
      opacity: .6;
    }

    .pipeline-card.inspecting {
      border-color: #4c8bf5;
      box-shadow: 0 0 0 1px rgba(76, 139, 245, .25);
    }

    .pipeline-card.is-dragging {
      opacity: .6;
    }

    .pipeline-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .5em;
    }

    .pipeline-card-title {
      display: inline-flex;
      align-items: center;
      gap: .4em;
      font-weight: 600;
      font-size: .95em;
    }

    .drag-handle {
      cursor: grab;
      color: #666;
      font-size: 1.1em;
      line-height: 1;
      user-select: none;
    }

    .pipeline-card-controls {
      display: flex;
      flex-wrap: wrap;
      gap: .75em;
      font-size: .85em;
    }

    .pipeline-card-controls label {
      display: inline-flex;
      align-items: center;
      gap: .35em;
      cursor: pointer;
    }

    .pipeline-label {
      display: flex;
      flex-direction: column;
      gap: .3em;
      font-size: .85em;
    }

    .pipeline-label-input {
      font-size: .95em;
      padding: .35em .45em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .pipeline-card button {
      font-size: .85em;
      padding: .35em .6em;
      margin-right: 0;
    }

    .pipeline-empty {
      color: #666;
      font-size: .9em;
      padding: .5em .25em;
      text-align: center;
    }

    .pipeline-inspector {
      border-top: 1px solid #ddd;
      padding: .9em 1em;
      background: #fff;
    }

    .pipeline-inspector.hidden {
      display: none;
    }

    .pipeline-inspector h3 {
      margin: 0 0 .6em 0;
      font-size: 1em;
    }

    .pipeline-inspector form {
      display: flex;
      flex-direction: column;
      gap: .6em;
    }

    .pipeline-inspector label {
      display: flex;
      flex-direction: column;
      gap: .3em;
      font-size: .85em;
    }

    .pipeline-inspector input,
    .pipeline-inspector select {
      font-size: .95em;
      padding: .35em .45em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .pipeline-inspector-actions {
      display: flex;
      justify-content: flex-end;
      gap: .5em;
      margin-top: .4em;
    }

    /* Pipeline progress overlay */
    #ppOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .25);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #ppOverlay.show {
      display: flex;
    }

    .ppCard {
      min-width: 320px;
      max-width: 90vw;
      background: #fff;
      border: 1px solid #e3e3e3;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .15);
      padding: 16px 18px;
      color: #222;
    }

    .ppTitle {
      font-weight: 700;
      margin-bottom: 8px;
    }

    .ppStatus {
      font-size: .95em;
      color: #444;
      margin: 8px 0 12px;
    }

    .ppBar {
      height: 8px;
      background: #eee;
      border-radius: 9999px;
      overflow: hidden;
    }

    .ppBarInner {
      height: 100%;
      width: 0%;
      background: #4c8bf5;
      transition: width .2s ease;
    }

    .ppActions {
      display: flex;
      justify-content: flex-end;
      gap: .5em;
      margin-top: 10px;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Open SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="mainContent">
    <div id="viewerColumn">
      <div id="controls">
        <label for="key1_idx_slider">key1 index:</label>
        <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1"
          oninput="updateKey1Display(); fetchAndPlot()" />
        <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;"
          onchange="syncSliderWithInput(); fetchAndPlot()" />
        <button onclick="fetchAndPlot()">Plot</button>
        <button id="pickModeBtn" onclick="togglePickMode()">Pick Mode: OFF</button>
        <select id="layerSelect" onchange="drawSelectedLayer()">
          <option value="raw" selected>raw</option>
        </select>
        <label style="margin-left:8px">σmax (ms):
          <input id="sigma_ms_max" type="number" value="20" step="1" min="1" style="width:5em"
            oninput="onSigmaChange()">
        </label>
        <label style="margin-left:8px">Pick:
          <select id="pick_method" onchange="onPickMethodChange()">
            <option value="argmax" selected>argmax</option>
            <option value="expectation">expectation</option>
          </select>
        </label>
        <label style="margin-left:8px">Snap:
          <select id="snap_mode" onchange="localStorage.setItem('snap_mode', this.value)">
            <option value="none" selected>none</option>
            <option value="peak">peak ↑</option>
            <option value="trough">trough ↓</option>
            <option value="rise">rise ⇑</option>
          </select>
        </label>
        <label style="margin-left:8px">Subsample:
          <select id="snap_refine" onchange="localStorage.setItem('snap_refine', this.value)">
            <option value="none" selected>none</option>
            <option value="parabolic">parabolic (peak/trough)</option>
            <option value="zc">zero-cross (rise)</option>
          </select>
        </label>
        <label>±ms:
          <input id="snap_ms" type="number" value="4" step="0.5" style="width:4.2em"
            oninput="localStorage.setItem('snap_ms', this.value)">
        </label>
        <label><input type="checkbox" id="showFbPred"
            onchange="localStorage.setItem('showFbPred', this.checked); drawSelectedLayer(renderedStart, renderedEnd)">Show
          FB
          predicted</label>

        <button id="predictFbBtn" onclick="predictFromFb()">Predict from FB</button>
        <button type="button" onclick="exportPickIndexVectorNpy()">Export pick index vector (.npy)</button>
        <label for="gain">Gain:</label>
        <input type="range" id="gain" min="0.1" max="5" step="0.1" value="1" oninput="onGainChange()" />
        <span id="gain_display">1×</span>
        <label style="margin-left:8px">Wiggle threshold:
        <input id="wiggle_density" type="number" min="0.02" max="0.30" step="0.01" value="0.20"
          oninput="onWiggleDensityChange()">
        </label>
        <label for="colormap">Colormap:</label>
        <select id="colormap" onchange="onColormapChange()">
          <option value="Greys">Greys</option>
          <option value="RdBu">RdBu</option>
          <option value="BWR">BWR</option>
          <option value="Cividis">Cividis</option>
          <option value="Jet">Jet</option>
        </select>
        <label><input type="checkbox" id="cmReverse" onchange="onColormapChange()">reverse</label>
      </div>
      <div id="plot"></div>
    </div>
    <aside id="pipelinePanel">
      <div class="pipeline-header">
        <span>Pipeline</span>
        <div class="pipeline-actions">
          <button type="button" id="pipelineRunButton">▶ Run</button>
          <div class="pipeline-add">
            <button type="button" id="pipelineAddButton">+ Add Step ▾</button>
            <div class="pipeline-add-menu" id="pipelineAddMenu">
              <button type="button" data-step="bandpass">Bandpass</button>
              <button type="button" data-step="denoise">Denoise</button>
            </div>
          </div>
        </div>
      </div>
      <div id="pipelineCards"></div>
      <div id="pipelineInspector" class="pipeline-inspector hidden">
        <h3 id="pipelineInspectorTitle">Inspector</h3>
        <form id="pipelineInspectorForm">
          <div id="pipelineInspectorFields"></div>
          <div class="pipeline-inspector-actions">
            <button type="button" id="pipelineInspectorClose">Close</button>
            <button type="submit" id="pipelineInspectorSave">Save</button>
          </div>
        </form>
      </div>
    </aside>
  </div>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script src="/static/pako.min.js"></script>
  <script src="/static/msgpack.min.js"></script>
  <script src="/static/api.js"></script>
  <script src="/static/pipeline_ui.js"></script>
  <script>
    var key1Values = [];
    var currentFileId = '';
    var currentKey1Byte = 189;
    var currentKey2Byte = 193;
    var savedXRange = null;
    var savedYRange = null;
    var latestSeismicData = null;
    var rawSeismicData = null;
    var latestTapData = {};
    var latestPipelineKey = null;
    var latestWindowRender = null;
    var windowFetchToken = 0;
    let windowFetchCtrl = null; // active window-fetch controller (if any)
    let defaultDt = 0.002;
    let lastHover = null;
    let redrawPending = false;
    try {
      const storedDt = localStorage.getItem('segy.dt');
      if (storedDt !== null) {
        const parsed = parseFloat(storedDt);
        if (!Number.isNaN(parsed) && Number.isFinite(parsed) && parsed > 0) {
          defaultDt = parsed;
        }
      }
    } catch (_) { }
    window.defaultDt = defaultDt;
    // === A-7: Coordinate utilities (single source of truth) ===
    const Grid = {
      x0: 0,      // leftmost trace center
      stepX: 1,   // trace stride used for current render (1 for wiggle, stepX/factor for heatmap)
      y0: 0,      // top sample index center
      stepY: 1,   // sample stride used for current render (1 or stepY/factor)
      get dt() { return (window.defaultDt ?? defaultDt) || 0.002; }
    };
    function setGrid({ x0, stepX, y0, stepY }) {
      Grid.x0 = Number.isFinite(x0) ? x0 : 0;
      Grid.stepX = Number.isFinite(stepX) ? stepX : 1;
      Grid.y0 = Number.isFinite(y0) ? y0 : 0;
      Grid.stepY = Number.isFinite(stepY) ? stepY : 1;
    }

    function buildLayout({
      mode,
      x0,
      x1,
      y0,
      y1,
      stepX = 1,
      stepY = 1,
      totalSamples,
      dt,
      savedXRange,
      savedYRange,
      clickmode,
      dragmode,
      uirevision,
      fbTitle = null,
    }) {
      const effectiveDt = typeof dt === 'number' ? dt : 0;
      const xaxis = {
        title: 'Trace',
        showgrid: false,
        tickfont: { color: '#000' },
        titlefont: { color: '#000' },
      };
      const yaxis = {
        title: 'Time (s)',
        showgrid: false,
        tickfont: { color: '#000' },
        titlefont: { color: '#000' },
      };

      if (mode === 'wiggle') {
        const defaultXRange = [x0, x1];
        const defaultYRange = [totalSamples * effectiveDt, 0];
        xaxis.autorange = false;
        xaxis.range = savedXRange ?? defaultXRange;
        yaxis.autorange = false;
        yaxis.range = savedYRange ?? defaultYRange;
      } else if (mode === 'heatmap') {
        const halfX = (stepX || 1) * 0.5;
        const halfYSec = (stepY || 1) * effectiveDt * 0.5;
        const defaultXRange = [x0 - halfX, x1 + halfX];
        const defaultYRange = [(y1 * effectiveDt) + halfYSec, (y0 * effectiveDt) + halfYSec];
        xaxis.autorange = !savedXRange;
        xaxis.range = savedXRange ?? defaultXRange;
        yaxis.autorange = false;
        yaxis.range = savedYRange ?? defaultYRange;
      }

      const layout = {
        xaxis,
        yaxis,
        clickmode,
        dragmode,
        uirevision,
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
      };

      if (fbTitle !== null) {
        layout.title = fbTitle;
      }

      return layout;
    }

    function buildPickShapes({
      manualPicks,
      predicted,
      xMin,
      xMax,
      showPredicted,
    }) {
      const manualShapes = (manualPicks || [])
        .filter((p) => p && typeof p.trace === 'number' && p.trace >= xMin && p.trace <= xMax)
        .map((p) => ({
          xref: 'x',
          yref: 'y',
          type: 'line',
          x0: p.trace - 0.4,
          x1: p.trace + 0.4,
          y0: p.time,
          y1: p.time,
          line: { color: 'red', width: 2 },
        }));

      const predictedShapes = (predicted || [])
        .filter((p) => p && typeof p.trace === 'number' && p.trace >= xMin && p.trace <= xMax)
        .map((p) => ({
          xref: 'x',
          yref: 'y',
          type: 'line',
          x0: p.trace - 0.4,
          x1: p.trace + 0.4,
          y0: p.time,
          y1: p.time,
          line: { color: '#1f77b4', width: 5, dash: 'dot' },
        }));

      return [...manualShapes, ...(showPredicted ? predictedShapes : [])];
    }
    function getPlotEnv() {
      const gd = document.getElementById('plot');
      const rect = gd?.getBoundingClientRect();
      const m = gd?._fullLayout?._size;   // {l,t,w,h}
      const xa = gd?._fullLayout?.xaxis;
      const ya = gd?._fullLayout?.yaxis;
      if (!gd || !rect || !m || !xa || !ya) return null;
      return { gd, rect, m, xa, ya };
    }
    // clientX/Y -> data X/Y using Plotly p2d
    function dataXYFromClient(clientX, clientY) {
        const env = getPlotEnv(); if (!env) return null;
        const { rect, m, xa, ya } = env;
        let x = Number.NaN, y = Number.NaN;
        if (Number.isFinite(clientX)) {
            const innerX = clientX - rect.left - m.l;
            x = xa.p2d(innerX);
          }
        if (Number.isFinite(clientY)) {
            const innerY = clientY - rect.top - m.t;
            y = ya.p2d(innerY);
          }
        return { x, y };
      }

    // Shared snap: snap to the center of the current cell/trace line
    function snapTraceFromDataX(x) {
      const k = Math.round((x - Grid.x0) / Grid.stepX);
      return Grid.x0 + k * Grid.stepX;
    }
    function snapTimeFromDataY(y) {
      const idx = y / Grid.dt;
      const k = Math.round((idx - Grid.y0) / Grid.stepY);
      const snappedIdx = Grid.y0 + k * Grid.stepY;
      return snappedIdx * Grid.dt;
    }
    // Public helpers
    function traceAtPixel(clientX) {
        const env = getPlotEnv(); if (!env) return NaN;
        const { rect, m, xa } = env;
        const innerX = clientX - rect.left - m.l;
        const x = xa.p2d(innerX);
        if (!Number.isFinite(x)) return NaN;
        return snapTraceFromDataX(x);
      }
    function pixelForTrace(trace) {
      const env = getPlotEnv(); if (!env) return null;
      const { rect, m, xa } = env;
      const snapped = snapTraceFromDataX(trace);
      const inner = xa.d2p(snapped);
      return rect.left + m.l + inner; // clientX
    }
    function timeAtPixel(clientY) {
        const env = getPlotEnv(); if (!env) return NaN;
        const { rect, m, ya } = env;
        const innerY = clientY - rect.top - m.t;
        const y = ya.p2d(innerY);
        if (!Number.isFinite(y)) return NaN;
        return snapTimeFromDataY(y);
      }
    const PREFETCH_WIDTH = 3;
    const FALLBACK_MAX = 8;
    const HARD_LIMIT_BYTES = 512 * 1024 * 1024;
    const WINDOW_FETCH_DEBOUNCE_MS = 120;
    const FETCH_DEBOUNCE_MS = 200;
    const WINDOW_MAX_POINTS = 1_200_000;
    const LS = { DRAG_BASE: 'drag_base' };
    // UI-adjustable threshold for Wiggle/Heatmap decision (persisted)
    let WIGGLE_DENSITY_THRESHOLD = parseFloat(localStorage.getItem('wiggle_density') || '0.20');

    (function syncWiggleInit() {
        const el = document.getElementById('wiggle_density');
        if (!el) return;
        const saved = localStorage.getItem('wiggle_density');
        const min = parseFloat(el.min) || 0.02;
        const max = parseFloat(el.max) || 0.30;
        let v = saved != null ? parseFloat(saved) : parseFloat(el.value) || 0.20;
        if (!Number.isFinite(v)) v = 0.20;
        v = Math.min(max, Math.max(min, v));
        el.value = v.toFixed(2);
        WIGGLE_DENSITY_THRESHOLD = v;
      })();

    if (!Number.isFinite(WIGGLE_DENSITY_THRESHOLD)) {
      WIGGLE_DENSITY_THRESHOLD = 0.10;
    }
    const WIGGLE_MAX_POINTS = 2_500_000;

    const cache = new Map(); // key -> { f32: Float32Array }
    const inflight = new Map();
    const CACHE_LIMIT = 12;
    function cacheKey(val, mode) { return `${val}|${mode}`; }
    var sectionShape = null;
    var renderedStart = null;
    var renderedEnd = null;
    var picks = [];
    var predictedPicks = [];
    const fbPredCache = new Map(); // key: "key1|layer|pipelineKey"
    var latestFbProbTraces = null;
    var currentFbKey = null;
    var fbPredReqId = 0;
    var downsampleFactor = 1;
    var isPickMode = false;
    var linePickStart = null;
    var deleteRangeStart = null;

    let uiResetNonce = 0;
    function currentUiRevision() {
      const sel = document.getElementById('layerSelect');
      const layer = sel ? sel.value : 'raw';
      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];
      const pKey = window.latestPipelineKey || '';
      return `rev:${currentFileId}|${key1Val}|${layer}|${pKey}|${uiResetNonce}`;
    }

  function withSuppressedRelayout(promiseLike) {
      suppressRelayout = true;
      if (promiseLike && typeof promiseLike.finally === 'function') {
          return promiseLike.finally(() => { suppressRelayout = false; });
        }
      suppressRelayout = false;
      return promiseLike;
    }

    function snapshotAxesRangesFromDOM() {
      const gd = document.getElementById('plot');
      const xa = gd?._fullLayout?.xaxis;
      const ya = gd?._fullLayout?.yaxis;
      if (xa && Array.isArray(xa.range) && xa.range.length === 2) {
        savedXRange = [xa.range[0], xa.range[1]];
      }
      if (ya && Array.isArray(ya.range) && ya.range.length === 2) {
        const y0 = ya.range[0], y1 = ya.range[1];
        // 上下逆レンジでも扱えるように max/min 順で保存
        savedYRange = y0 > y1 ? [y0, y1] : [y1, y0];
      }
    }

    // ---- Minimal NPY v1.0 encoder for 1-D TypedArray ----
    // dtype must be '<i4' here (little-endian int32). Shape is (N,)
    function npyEncode1d(typedArray, dtype /* '<i4' */) {
      const N = typedArray.length;
      const magicBytes = new Uint8Array([0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59]);
      const ver = new Uint8Array([1, 0]);

      // Python-style header string
      const shapeStr = `(${N},)`;
      let headerStr = `{'descr': '${dtype}', 'fortran_order': False, 'shape': ${shapeStr}, }`;
      headerStr += '\n';

      const enc = new TextEncoder();
      let headerBytes = enc.encode(headerStr);

      // Pad so that (10 + headerLen) % 16 === 0 ; 10 = len(magic)+len(ver)+len(hlen)
      const preambleLen = 10;
      const mod = (preambleLen + headerBytes.length) % 16;
      if (mod !== 0) {
        const pad = 16 - mod;
        const padded = new Uint8Array(headerBytes.length + pad);
        padded.set(headerBytes, 0);
        // fill with spaces; ensure last char is '\n'
        padded.fill(' '.charCodeAt(0), headerBytes.length);
        padded[padded.length - 1] = '\n'.charCodeAt(0);
        headerBytes = padded;
      }

      const hlenLE = new Uint8Array(2);
      new DataView(hlenLE.buffer).setUint16(0, headerBytes.length, true);

      const totalLen = magicBytes.length + ver.length + hlenLE.length + headerBytes.length + typedArray.byteLength;
      const out = new Uint8Array(totalLen);
      let o = 0;
      out.set(magicBytes, o); o += magicBytes.length;
      out.set(ver, o);        o += ver.length;
      out.set(hlenLE, o);     o += hlenLE.length;
      out.set(headerBytes, o); o += headerBytes.length;
      out.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), o);
      return out;
    }

    // ---- Export current section's manual picks as int32 index vector (.npy) ----
    async function exportPickIndexVectorNpy() {
      if (!sectionShape || !Array.isArray(sectionShape) || sectionShape.length < 2) {
        alert('Section shape is unknown yet.');
        return;
      }
      const nTraces = sectionShape[0];
      const nSamples = sectionShape[1];
      const dt = (window.defaultDt ?? defaultDt);

      // Build trace -> time_sec map using ONLY manual picks (red).
      // If multiple picks on same trace, take the latest occurrence.
      const traceToTime = new Map();
      for (const p of (picks || [])) {
        const tr = Math.round(p.trace);
        if (tr >= 0 && tr < nTraces && Number.isFinite(p.time)) {
          traceToTime.set(tr, p.time);
        }
      }

      // Create int32 vector (length = nTraces), default -1 for "no pick"
      const vec = new Int32Array(nTraces);
      vec.fill(-1);

      for (const [tr, t] of traceToTime.entries()) {
        let idx = Math.round(t / dt);
        if (!Number.isFinite(idx) || idx < 0 || idx >= nSamples) {
          idx = -1;
        }
        vec[tr] = idx;
      }

      // Encode as .npy (<i4, shape (N,))
      const npy = npyEncode1d(vec, '<i4');

      function safeName(s) { return String(s).replace(/[^-_.a-zA-Z0-9]/g, '_'); }

      // File name
      const slider = document.getElementById('key1_idx_slider');
      const idx = parseInt(slider?.value ?? '0', 10);
      const key1Val = key1Values?.[idx] ?? 'cur';
      const fileId = safeName((document.getElementById('file_id')?.value) || 'file');
      const fname = `pvec_idx_${fileId}_${key1Val}.npy`;

      // Save (prefer File System Access API on secure contexts)
        try {
            if (window.isSecureContext && 'showSaveFilePicker' in window) {
                const handle = await window.showSaveFilePicker({
                suggestedName: fname,
                    types: [{ description: 'NumPy array', accept: { 'application/octet-stream': ['.npy'] } }],
                  });
              const writable = await handle.createWritable();
              await writable.write(npy);
              await writable.close();
            } else {
            // Fallback: anchor download (may show HTTP warning on non-HTTPS)
              const blob = new Blob([npy], { type: 'application/octet-stream' });
            const href = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = href;
            a.download = fname;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(href), 1000);
            if (!window.isSecureContext) {
                console.warn('Downloading over an insecure context (HTTP). Consider HTTPS/localhost to silence warnings.');
              }
          }
      } catch (err) {
          console.error('Save failed:', err);
          alert('Save failed: ' + (err && err.message ? err.message : err));
        }
    }

    let suppressRelayout = false;       // ignore relayouts we cause internally
    let isRelayouting = false;          // true while user is actively adjusting viewport
    let forceFullExtentOnce = false;    // next window calc uses full extent with no padding

    // 追加：現在のFB計算に紐づくレイヤ/パイプラインキー
    let currentFbLayer = 'raw';
    let currentFbPipelineKey = null;

    let dragBase = localStorage.getItem(LS.DRAG_BASE) || 'zoom'; // 'zoom' or 'pan'
    let dragOverride = null; // 一時上書き（'pan' を入れる）

    function getBaseDragMode() {
      return (dragBase === 'pan') ? 'pan' : 'zoom';
    }

    function setBaseDragMode(mode) {
      const next = (mode === 'pan') ? 'pan' : 'zoom';
      if (dragBase !== next) {
        dragBase = next;
        try { localStorage.setItem(LS.DRAG_BASE, next); } catch (_) { }
        applyDragMode();
      }
    }

    function getOverrideDragMode() {
      if (dragOverride) return dragOverride;
      if (isPickMode) return false;
      return null;
    }

    function effectiveDragMode() {
      const over = getOverrideDragMode();
      if (over !== null && over !== undefined) return over;
      return getBaseDragMode();
    }
    function applyDragMode() {
      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;
      const dm = effectiveDragMode();
      if (applyDragMode._last === dm) return; // 余計な relayout 防止
      applyDragMode._last = dm;
      safeRelayout(plotDiv, { dragmode: dm });
    }

    function debounce(fn, wait) {
        let t = null;
        return function (...args) {
          if (t) clearTimeout(t);
          t = setTimeout(() => { t = null; fn.apply(this, args); }, wait);
        };
      }

    function safeRelayout(gd, props) {
      suppressRelayout = true;
      try {
        const result = Plotly.relayout(gd, props);
        if (result && typeof result.finally === 'function') {
          return result.finally(() => {
            suppressRelayout = false;
          });
        }
        suppressRelayout = false;
        return result;
      } catch (err) {
        suppressRelayout = false;
        throw err;
      }
    }

    // 統一キー関数（FB予測キャッシュ用）
    function fbCacheKey(k1, layer, pKey) {
      return `${k1}|${layer}|${pKey ?? 'raw'}`;
    }

    // 一時上書きの適用
    function setAltPan(on) {
      const next = on ? 'pan' : null;
      if (dragOverride !== next) {
        dragOverride = next;
        applyDragMode();
      }
    }

    function currentDesiredMode() {
      const win = currentVisibleWindow();
      const plotDiv = document.getElementById('plot');
      if (!win || !plotDiv) return null;
      const wantWig = wantWiggleForWindow({
        tracesVisible: win.nTraces,
        samplesVisible: win.nSamples,
        widthPx: plotDiv.clientWidth || 1,
      });
      return wantWig ? 'wiggle' : 'heatmap';
    }

    function checkModeFlipAndRefetch() {
      const desired = currentDesiredMode();
      if (!desired) return;

      const cur = (latestWindowRender && latestWindowRender.mode) || null;

      if (desired === 'wiggle') {
        // wiggleは step_x=1/step_y=1 が前提。heatmapの粗サンプルを流用しない
        const needFresh =
          !latestWindowRender ||
          cur !== 'wiggle' ||
          latestWindowRender.stepX !== 1 ||
          latestWindowRender.stepY !== 1;

        if (needFresh) scheduleWindowFetch();
      } else {
        // heatmapへ切替も今のwindowがwiggleだったら取り直す（負荷を抑えるため）
        const needFresh = !latestWindowRender || cur !== 'heatmap';
        if (needFresh) scheduleWindowFetch();
      }
    }

    // （任意：すでに入れているならそのままでOK）
    function maybeFetchIfOutOfWindow() {
      if (!latestWindowRender || !sectionShape) {
        scheduleWindowFetch();
        return;
      }
      const { x0, x1, y0, y1 } = latestWindowRender;
      const win = currentVisibleWindow();
      if (!win) return;
      const guardX = Math.max(1, Math.floor((x1 - x0 + 1) * 0.05));
      const guardY = Math.max(1, Math.floor((y1 - y0 + 1) * 0.05));
      const insideX = win.x0 >= x0 + guardX && win.x1 <= x1 - guardX;
      const insideY = win.y0 >= y0 + guardY && win.y1 <= y1 - guardY;
      if (!(insideX && insideY)) scheduleWindowFetch();
    }

    const onViewportSettled = debounce(() => {
      if (suppressRelayout || isRelayouting) return;
      checkModeFlipAndRefetch();
      maybeFetchIfOutOfWindow();
    }, FETCH_DEBOUNCE_MS);

    function installPlotlyViewportHandlersOnce() {
      const plotDiv = document.getElementById('plot');
      if (!plotDiv || plotDiv.__viewportHandlersInstalled) return;
      plotDiv.__viewportHandlersInstalled = true;

      plotDiv.on('plotly_relayouting', () => {
        if (suppressRelayout) return;
        isRelayouting = true;
      });

      plotDiv.on('plotly_relayout', (ev) => {
        if (suppressRelayout) return;
        isRelayouting = false;
        const result = handleRelayout(ev);
        if (result && typeof result.catch === 'function') {
          result.catch((err) => console.warn('handleRelayout failed', err));
        }
        if (redrawPending) {
            redrawPending = false;
            try { renderLatestView(); } catch (e) { console.warn('deferred render failed', e); }
          }
        onViewportSettled();
      });

      plotDiv.on('plotly_doubleclick', () => {
        if (suppressRelayout) return;
        isRelayouting = false;
        savedXRange = null;
        savedYRange = null;
        renderedStart = null;
        renderedEnd = null;
        forceFullExtentOnce = true;
        uiResetNonce++;
        onViewportSettled();
      });
    }

    // 入力系にフォーカスがある時は無効
    function canUseGlobalHotkey() {
      const el = document.activeElement;
      const tag = el?.tagName;
      return !(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || el?.isContentEditable);
    }

    // Alt 押してる間だけ pan
    window.addEventListener('keydown', (e) => {
      if (!canUseGlobalHotkey()) return;
      if (e.key === 'Alt' || e.altKey) setAltPan(true);
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'Alt' || !e.altKey) setAltPan(false);
    });

    // 取りこぼし対策
    window.addEventListener('blur', () => setAltPan(false));
    document.addEventListener('visibilitychange', () => { if (document.hidden) setAltPan(false); });
    window.addEventListener('pointerup', (e) => { if (!e.altKey) setAltPan(false); });

    function applyServerDt(obj) {
      const dtSec =
        obj && typeof obj.dt === 'number' && isFinite(obj.dt) && obj.dt > 0
          ? obj.dt
          : null;

      if (dtSec === null) return;

      const prev =
        typeof window.defaultDt === 'number' && isFinite(window.defaultDt)
          ? window.defaultDt
          : defaultDt;

      // dt が実際に変わった時だけ更新＆Yレンジ初期化
      if (!Number.isFinite(prev) || Math.abs(prev - dtSec) > 1e-12) {
        defaultDt = dtSec;
        window.defaultDt = dtSec;
        try { localStorage.setItem('segy.dt', String(dtSec)); } catch (_) { }
        savedYRange = null;
      }
    }

    const COLORMAPS = {
      Greys: 'Greys',
      RdBu: 'RdBu',
      BWR: [[0, 'blue'], [0.5, 'white'], [1, 'red']],
      Cividis: 'Cividis',
      Jet: 'Jet',
    };

    (function () {
      const saved = localStorage.getItem('gain');
      const el = document.getElementById('gain');
      const disp = document.getElementById('gain_display');
      if (el && disp) {
        const val = saved !== null ? parseFloat(saved) : parseFloat(el.value);
        el.value = val; disp.textContent = `${val}×`;
      }
    })();

    (function () {
      const sel = document.getElementById('colormap');
      const chk = document.getElementById('cmReverse');
      if (sel) {
        const saved = localStorage.getItem('colormap');
        if (saved) sel.value = saved;
      }
      if (chk) {
        const savedRev = localStorage.getItem('cmReverse');
        if (savedRev !== null) chk.checked = savedRev === 'true';
      }
    })();

    (function restoreFbUi() {
      const sig = localStorage.getItem('sigma_ms_max');
      if (sig !== null) {
        const s = document.getElementById('sigma_ms_max');
        if (s) s.value = parseFloat(sig);
      }
      const pm = localStorage.getItem('pick_method');
      if (pm) {
        const sel = document.getElementById('pick_method');
        if (sel) sel.value = pm;
      }
      const sh = localStorage.getItem('showFbPred');
      if (sh !== null) {
        const c = document.getElementById('showFbPred');
        if (c) c.checked = (sh === 'true');
      }
    })();

    (function restoreSnapUi() {
      const m = localStorage.getItem('snap_mode');
      if (m) {
        const el = document.getElementById('snap_mode');
        if (el) el.value = m;
      }
      const w = localStorage.getItem('snap_ms');
      if (w) {
        const el = document.getElementById('snap_ms');
        if (el) el.value = w;
      }
      const r = localStorage.getItem('snap_refine');
      if (r) {
        const el = document.getElementById('snap_refine');
        if (el) el.value = r;
      }
    })();

    // ★★★ FB確率取得：レイヤ/パイプライン対応（既存のジョブAPIを使用）
    async function fetchFbProb(key1Val, { layer = 'raw', pipelineKey = null } = {}) {
      const body = {
        file_id: currentFileId,
        key1_idx: key1Val,
        key1_byte: currentKey1Byte,
        key2_byte: currentKey2Byte,
        tile_h: 128,
        tile_w: 6016,
        overlap: 32,
        amp: true,
      };
      // パイプラインの特定レイヤで推論したい場合
      if (layer && layer !== 'raw' && pipelineKey) {
        body.pipeline_key = pipelineKey;
        body.tap_label = layer;
      }
      const res = await fetch('/fbpick_section_bin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        let message = `fbpick job failed (${res.status})`;
        try {
          const text = await res.text();
          if (text) {
            try {
              const parsed = JSON.parse(text);
              if (parsed && typeof parsed.detail === 'string') {
                message = parsed.detail;
              } else {
                message = text;
              }
            } catch (parseErr) {
              message = text;
            }
          }
        } catch (readErr) {
          // ignore body read errors
        }
        throw new Error(message);
      }
      const { job_id } = await res.json();

      // ポーリング
      while (true) {
        const st = await fetch(`/fbpick_job_status?job_id=${job_id}`);
        const js = await st.json();
        if (js.status === 'done') break;
        if (js.status === 'error') throw new Error(js.message || 'fbpick failed');
        await new Promise(r => setTimeout(r, 1000));
      }

      // 取得 & 復号
      const binRes = await fetch(`/get_fbpick_section_bin?job_id=${job_id}`);
      if (!binRes.ok) throw new Error('fbpick result fetch failed');
      const bin = new Uint8Array(await binRes.arrayBuffer());
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      const f32 = Float32Array.from(int8, v => v / obj.scale);
      return { f32, shape: obj.shape };
    }

    // prob2d: Array(H) of Float32Array(W); each row sums to ~1
    function picksFromProb(prob2d, dt, sigmaMaxMs = 20, method = 'argmax') {
      const H = prob2d.length;
      const W = prob2d[0].length;
      const picks = new Array(H).fill(-1);
      const dt_ms = dt * 1000;
      const eps = 1e-12;

      const t = new Float32Array(W);
      for (let i = 0; i < W; i++) t[i] = i;

      for (let h = 0; h < H; h++) {
        const p = prob2d[h];
        let s = 0.0;
        for (let i = 0; i < W; i++) s += p[i];
        if (!(s > eps) || !isFinite(s)) continue;
        const invs = 1.0 / s;
        let mu = 0.0;
        for (let i = 0; i < W; i++) mu += p[i] * t[i];
        mu *= invs;
        let v = 0.0;
        for (let i = 0; i < W; i++) {
          const d = t[i] - mu;
          v += p[i] * d * d;
        }
        v *= invs;
        const sigma_ms = Math.sqrt(Math.max(v, 0)) * dt_ms;
        if (sigma_ms > sigmaMaxMs) continue;
        if (method === 'expectation') {
          picks[h] = Math.round(mu);
        } else {
          let imax = 0, vmax = -Infinity;
          for (let i = 0; i < W; i++) if (p[i] > vmax) { vmax = p[i]; imax = i; }
          picks[h] = imax;
        }
      }
      return picks;
    }

    function installUnifiedClickRouter(plotDiv) {
      if (!plotDiv || plotDiv.__unifiedClickRouter) return;

      const onClick = (e) => {
        if (e.detail > 1) return; // keep Plotly double-click reset
        if (e.button !== 0) return;
        if (!isPickMode) return;
        if (dragOverride === 'pan' || e.altKey) return;
        if (isRelayouting) return;

        const activeEl = document.activeElement;
        if (activeEl && activeEl !== document.body) {
          const tag = activeEl.tagName;
          if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA' || activeEl.isContentEditable) {
            return;
          }
        }

        const env = getPlotEnv();
        if (!env) return;
        const { rect, m } = env;
        const innerX = e.clientX - rect.left;
        const innerY = e.clientY - rect.top;
        if (innerX < m.l || innerX > m.l + m.w || innerY < m.t || innerY > m.t + m.h) {
          return;
        }

        const tr = traceAtPixel(e.clientX);
        const tSec = timeAtPixel(e.clientY);
        if (!Number.isFinite(tr) || !Number.isFinite(tSec)) return;

        e.stopImmediatePropagation();
        e.stopPropagation();
        e.preventDefault();

        const maybePromise = handlePickNormalized({
          trace: snapTraceFromDataX(tr),
          time: snapTimeFromDataY(tSec),
          shiftKey: !!e.shiftKey,
          ctrlKey: !!e.ctrlKey,
          altKey: !!e.altKey,
        });
        if (maybePromise && typeof maybePromise.catch === 'function') {
          maybePromise.catch(err => console.warn('handlePickNormalized failed', err));
        }
      };

      const remover = () => {
        plotDiv.removeEventListener('click', onClick, true);
        if (plotDiv.__unifiedClickRouter === remover) {
          plotDiv.__unifiedClickRouter = null;
        }
      };
      plotDiv.addEventListener('click', onClick, { capture: true });
      plotDiv.__unifiedClickRouter = remover;
    }

    function attachPickListeners(plotDiv) {
      // relayout ハンドラは一度だけインストール
      installPlotlyViewportHandlersOnce();

      // 既存の pick/hover ハンドラを外す
      plotDiv.removeAllListeners('plotly_click');
      plotDiv.removeAllListeners('plotly_hover');
      plotDiv.removeAllListeners('plotly_unhover');

      if (plotDiv._genericClickHandler) {
        plotDiv.removeEventListener('click', plotDiv._genericClickHandler);
        plotDiv._genericClickHandler = null;
      }
      if (plotDiv._captureShiftHandler) {
        plotDiv.removeEventListener('click', plotDiv._captureShiftHandler, true);
        plotDiv._captureShiftHandler = null;
      }

      // 黒いホバーボックスと同じ値を保持
      plotDiv.on('plotly_hover', (e) => {
        const p = e?.points?.[0];
        if (!p) return;
        lastHover = {
          x: p.x,
          y: p.y,
          meta: Number.isFinite(p.data?.meta) ? p.data.meta : null,
          t: performance.now(),
        };
      });
      plotDiv.on('plotly_unhover', () => { lastHover = null; });

      installUnifiedClickRouter(plotDiv);
    }

    function computePicks(prob2d) {
      const sigmaMax = Number(document.getElementById('sigma_ms_max').value) || 20;
      const method = document.getElementById('pick_method').value;
      const dt = (window.defaultDt ?? defaultDt);
      const idxs = picksFromProb(prob2d, dt, sigmaMax, method);
      const out = [];
      for (let h = 0; h < idxs.length; h++) {
        const idx = idxs[h];
        if (idx >= 0) out.push({ trace: h, time: idx * dt });
      }
      return out;
    }

    function recomputeFbPicks() {
      if (!latestFbProbTraces) return;

      const idx0 = parseInt(document.getElementById('key1_idx_slider').value, 10);
      const keyAtNow = key1Values[idx0];
      const layerNow = (document.getElementById('layerSelect')?.value) || 'raw';
      const pKeyNow = window.latestPipelineKey || null;

      // 現在のセクション＆レイヤ＆パイプラインキーに紐づく確率以外は再計算しない
      if (currentFbKey !== keyAtNow ||
        currentFbLayer !== layerNow ||
        currentFbPipelineKey !== pKeyNow) {
        return;
      }

      const picksNow = computePicks(latestFbProbTraces);
      predictedPicks = picksNow;
      fbPredCache.set(fbCacheKey(currentFbKey, currentFbLayer, currentFbPipelineKey), picksNow);

      renderLatestView();
    }

    function onSigmaChange() {
      localStorage.setItem('sigma_ms_max', document.getElementById('sigma_ms_max').value);
      recomputeFbPicks();
    }
    function onPickMethodChange() {
      localStorage.setItem('pick_method', document.getElementById('pick_method').value);
      recomputeFbPicks();
    }

    async function predictFromFb() {
      // Snapshot
      const idx0 = parseInt(document.getElementById('key1_idx_slider').value, 10);
      const keyAtStart = key1Values[idx0];
      const layerAtStart = (document.getElementById('layerSelect')?.value) || 'raw';
      const pipelineKeyAtStart = window.latestPipelineKey || null;

      // Request token
      const reqToken = ++fbPredReqId;

      const btn = document.getElementById('predictFbBtn');
      if (btn) btn.disabled = true;

      try {
        // Ensure probs
        let tracesLocal = latestFbProbTraces;
        if (!tracesLocal ||
          currentFbKey !== keyAtStart ||
          currentFbLayer !== layerAtStart ||
          currentFbPipelineKey !== pipelineKeyAtStart) {

          const { f32, shape } = await fetchFbProb(keyAtStart, { layer: layerAtStart, pipelineKey: pipelineKeyAtStart });
          const [nTraces, nSamples] = shape;
          const traces = new Array(nTraces);
          for (let i = 0; i < nTraces; i++) {
            traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
          }
          tracesLocal = traces;
        }

        // Compute picks locally
        const picks = computePicks(tracesLocal);

        // Guard against stale
        const idxNow = parseInt(document.getElementById('key1_idx_slider').value, 10);
        const keyNow = key1Values[idxNow];
        const layerNow = (document.getElementById('layerSelect')?.value) || 'raw';
        const pipelineKeyNow = window.latestPipelineKey || null;
        if (reqToken !== fbPredReqId ||
          keyNow !== keyAtStart ||
          layerNow !== layerAtStart ||
          pipelineKeyNow !== pipelineKeyAtStart) {
          return;
        }

        // Commit
        predictedPicks = picks;
        latestFbProbTraces = tracesLocal;
        currentFbKey = keyAtStart;
        currentFbLayer = layerAtStart;
        currentFbPipelineKey = pipelineKeyAtStart;
        fbPredCache.set(fbCacheKey(keyAtStart, layerAtStart, pipelineKeyAtStart), picks);

        // Replot
        renderLatestView();
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    function onWiggleDensityChange() {
      const el = document.getElementById('wiggle_density');
      const v = parseFloat(el?.value);
      if (Number.isFinite(v) && v > 0) {
        WIGGLE_DENSITY_THRESHOLD = v;
        try { localStorage.setItem('wiggle_density', String(v)); } catch (_) { }
        // Apply now: re-evaluate window mode and redraw
        renderLatestView();
        scheduleWindowFetch();
      }
    }

    // Restore UI on load
    (function restoreWiggleUi() {
      const saved = localStorage.getItem('wiggle_density');
      const el = document.getElementById('wiggle_density');
      if (!el) return;
      if (saved != null) {
          let v = parseFloat(saved);
          if (!Number.isFinite(v)) v = 0.10;
          const min = parseFloat(el.min) || 0.02;
          const max = parseFloat(el.max) || 0.30;
          v = Math.min(max, Math.max(min, v));
          el.value = v.toFixed(2);
          WIGGLE_DENSITY_THRESHOLD = v;
        } else {
          // localStorage未設定時はinputの既定値を信頼
            let v = parseFloat(el.value) || 0.10;
          WIGGLE_DENSITY_THRESHOLD = v;
        }
    })();

    function onGainChange() {
      const val = document.getElementById('gain').value;
      document.getElementById('gain_display').textContent = `${parseFloat(val)}×`;
      localStorage.setItem('gain', val);
      renderLatestView();
    }

    function onColormapChange() {
      const sel = document.getElementById('colormap');
      const chk = document.getElementById('cmReverse');
      if (sel) localStorage.setItem('colormap', sel.value);
      if (chk) localStorage.setItem('cmReverse', chk.checked);
      renderLatestView();
    }

    function togglePickMode() {
      isPickMode = !isPickMode;
      const btn = document.getElementById('pickModeBtn');
      btn.textContent = isPickMode ? 'Pick Mode: ON' : 'Pick Mode: OFF';
      btn.classList.toggle('active', isPickMode);
      linePickStart = null;
      deleteRangeStart = null;
      renderLatestView();
      applyDragMode();
    }

    function getSeismicForProcessing() {
      const sel = document.getElementById('layerSelect');
      const layer = sel?.value || 'raw';
      return layer === 'raw' ? rawSeismicData : (latestTapData[layer] || rawSeismicData);
    }

    // 3-point parabolic interpolation around index i (for peak/trough). Returns a float index.
    function parabolicRefine(arr, i) {
      const n = arr.length;
      const ii = Math.max(1, Math.min(n - 2, i | 0));
      const y1 = arr[ii - 1], y2 = arr[ii], y3 = arr[ii + 1];
      const denom = (y1 - 2 * y2 + y3);
      if (!Number.isFinite(denom) || Math.abs(denom) < 1e-12) return ii; // near-flat → skip
      const delta = 0.5 * (y1 - y3) / denom;          // typically within ~[-0.5, 0.5]
      if (!Number.isFinite(delta) || Math.abs(delta) > 0.6) return ii;   // outlier move → skip
      const xhat = ii + delta;
      if (!Number.isFinite(xhat)) return ii;
      return Math.max(0, Math.min(n - 1, xhat));
    }

    // Upward zero-crossing linear interpolation near i (for rise). Returns a float index.
    function zeroCrossRefine(arr, i) {
      const n = arr.length;
      let i0 = Math.max(0, Math.min(n - 2, i | 0));
      let i1 = i0 + 1;

      // Prefer a nearby upward zero-crossing if present
      if (!(arr[i0] <= 0 && arr[i1] > 0)) {
        if (i0 > 0 && (arr[i0 - 1] <= 0 && arr[i0] > 0)) { i0 = i0 - 1; i1 = i0 + 1; }
        else if (i1 < n - 1 && (arr[i1] <= 0 && arr[i1 + 1] > 0)) { i0 = i1; i1 = i0 + 1; }
        else return i; // no clear upward zero-cross nearby → keep integer index
      }

      const dy = (arr[i1] - arr[i0]);
      if (!Number.isFinite(dy) || Math.abs(dy) < 1e-12) return i; // near-flat → skip
      const frac = (0 - arr[i0]) / dy;                // ∈ [0, 1]
      const xhat = i0 + frac;
      if (!Number.isFinite(xhat)) return i;
      return Math.max(0, Math.min(n - 1, xhat));
    }

    // Adjust a pick's time (seconds) on a given trace to the nearest feature in ±window.
    // Uses the *original* data of the currently selected layer (raw or pipeline layer).
    function adjustPickToFeature(trace, timeSec) {
      const mode = (document.getElementById('snap_mode')?.value) || 'none';
      if (mode === 'none') return timeSec;

      const refineMode = (document.getElementById('snap_refine')?.value) || 'none';

      const seismic = getSeismicForProcessing(); // raw or current TAP layer
      if (!seismic || !seismic[trace]) return timeSec;

      const dt = (window.defaultDt ?? defaultDt);
      const arr = seismic[trace]; // Float32Array (one trace)
      if (!arr || !arr.length) return timeSec;

      const i0 = Math.round(timeSec / dt);

      // ±window in samples
      const ms = parseFloat(document.getElementById('snap_ms')?.value) || 4;
      const rad = Math.max(1, Math.round((ms / 1000) / dt));

      // keep one-sample margin for central differences
      const lo = Math.max(1, i0 - rad);
      const hi = Math.min(arr.length - 2, i0 + rad);

      let idx = i0;

      if (mode === 'peak') {
        // 近傍の「局所最大」(arr[i-1] <= arr[i] >= arr[i+1]) のうち i0 に最も近い点
        let best = null, bestDist = Infinity;
        for (let i = lo; i <= hi; i++) {
          if (arr[i] >= arr[i - 1] && arr[i] >= arr[i + 1]) {
            const d = Math.abs(i - i0);
            if (d < bestDist) { bestDist = d; best = i; }
          }
        }
        if (best != null) idx = best;
        else {
          // 局所最大がない時のフォールバック：従来どおり最大値へ
          let vmax = -Infinity;
          for (let i = lo; i <= hi; i++) { const v = arr[i]; if (v > vmax) { vmax = v; idx = i; } }
        }
      } else if (mode === 'trough') {
        // 近傍の「局所最小」(arr[i-1] >= arr[i] <= arr[i+1]) のうち最も近い点
        let best = null, bestDist = Infinity;
        for (let i = lo; i <= hi; i++) {
          if (arr[i] <= arr[i - 1] && arr[i] <= arr[i + 1]) {
            const d = Math.abs(i - i0);
            if (d < bestDist) { bestDist = d; best = i; }
          }
        }
        if (best != null) idx = best;
        else {
          // フォールバック：従来どおり最小値へ
          let vmin = Infinity;
          for (let i = lo; i <= hi; i++) { const v = arr[i]; if (v < vmin) { vmin = v; idx = i; } }
        }
      } else if (mode === 'rise') {
        // 「最も近い上りエッジ」を優先：ゼロクロス↑があれば最優先、なければ最大正勾配
        let best = null, bestDist = Infinity;
        for (let i = lo; i < hi; i++) {
          if (arr[i] <= 0 && arr[i + 1] > 0) {
            const cand = (Math.abs(arr[i]) < Math.abs(arr[i + 1])) ? i : i + 1;
            const d = Math.abs(cand - i0);
            if (d < bestDist) { bestDist = d; best = cand; }
          }
        }
        if (best != null) idx = best;
        else {
          let smax = -Infinity;
          for (let i = lo; i <= hi; i++) {
            const s = arr[i + 1] - arr[i - 1];
            if (s > 0 && s > smax) { smax = s; idx = i; }
          }
        }
      }

      let idxFloat = idx;
      if (mode === 'peak' || mode === 'trough') {
        if (refineMode === 'parabolic') idxFloat = parabolicRefine(arr, idx);
      } else if (mode === 'rise') {
        if (refineMode === 'zc') idxFloat = zeroCrossRefine(arr, idx);
      }

      return idxFloat * dt;
    }

    function putCacheF32(key, f32) {
      if (cache.size >= CACHE_LIMIT) {
        const oldestKey = cache.keys().next().value;
        const old = cache.get(oldestKey);
        if (old) old.f32 = null;
        cache.delete(oldestKey);
      }
      cache.set(key, { f32 });

      const canCheckMemory = performance.memory && performance.memory.usedJSHeapSize > 0;
      const used = canCheckMemory ? performance.memory.usedJSHeapSize : 0;

      console.log('--- putCache called ---');
      console.log('Added key:', cache.keys());
      console.log('Cache size:', cache.size);
      if (canCheckMemory) {
        const total = performance.memory.totalJSHeapSize;
        console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB`);
      } else {
        console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB (fallback, no total)`);
      }

      if (used > HARD_LIMIT_BYTES) {
        console.warn(`⚠ Memory limit exceeded! (${(used / 1024 / 1024).toFixed(1)} MB > 512 MB)`);
        let removed = 0;
        while (cache.size > 1) {
          const removedKey = cache.keys().next().value;
          const entry = cache.get(removedKey);
          if (entry) entry.f32 = null;
          cache.delete(removedKey);
          removed++;
        }
        console.warn(`Evicted ${removed} items due to hard heap limit.`);
        console.log('Remaining keys:', Array.from(cache.keys()));
      }
      console.log('------------------------');
    }

    function getCacheF32(key) {
      if (!cache.has(key)) return null;
      const entry = cache.get(key);
      cache.delete(key); cache.set(key, entry); // refresh LRU
      return entry;
    }

    function roundUpPowerOfTwo(value) {
      let v = Math.max(1, Math.floor(value));
      v -= 1;
      v |= v >> 1;
      v |= v >> 2;
      v |= v >> 4;
      v |= v >> 8;
      v |= v >> 16;
      return v + 1;
    }

    function computeStepsForWindow({
      tracesVisible,
      samplesVisible,
      widthPx,
      heightPx,
      oversampleX = 1.2,
      oversampleY = 1.2,
      maxPoints = WINDOW_MAX_POINTS,
    }) {
      const ratio = window.devicePixelRatio || 1;
      const effW = Math.max(1, Math.round(widthPx * ratio));
      const effH = Math.max(1, Math.round(heightPx * ratio));
      let stepX = Math.max(1, Math.ceil(tracesVisible / (effW * oversampleX)));
      let stepY = Math.max(1, Math.ceil(samplesVisible / (effH * oversampleY)));

      const tracesOut = () => Math.ceil(tracesVisible / stepX);
      const samplesOut = () => Math.ceil(samplesVisible / stepY);

      let guard = 0;
      while (tracesOut() * samplesOut() > maxPoints && guard < 512) {
        if (tracesOut() / effW > samplesOut() / effH) {
          stepX += 1;
        } else {
          stepY += 1;
        }
        guard += 1;
      }

      stepX = roundUpPowerOfTwo(stepX);
      stepY = roundUpPowerOfTwo(stepY);

      guard = 0;
      while (Math.ceil(tracesVisible / stepX) * Math.ceil(samplesVisible / stepY) > maxPoints && guard < 512) {
        if (tracesVisible / stepX > samplesVisible / stepY) {
          stepX = roundUpPowerOfTwo(stepX + 1);
        } else {
          stepY = roundUpPowerOfTwo(stepY + 1);
        }
        guard += 1;
      }

      return { step_x: stepX, step_y: stepY };
    }

    function wantWiggleForWindow({ tracesVisible, samplesVisible, widthPx }) {
      const density = tracesVisible / Math.max(1, widthPx);
      if (density >= WIGGLE_DENSITY_THRESHOLD) return false;
      if ((tracesVisible * samplesVisible) > WIGGLE_MAX_POINTS) return false;
      return true;
    }

    function currentVisibleWindow() {
      if (!sectionShape) return null;
      const [totalTraces, totalSamples] = sectionShape;

      // X range
      let x0, x1;
      if (forceFullExtentOnce) {
        x0 = 0; x1 = totalTraces - 1;
      } else if (savedXRange && savedXRange.length === 2) {
        const minX = Math.min(savedXRange[0], savedXRange[1]);
        const maxX = Math.max(savedXRange[0], savedXRange[1]);
        x0 = Math.floor(minX);
        x1 = Math.ceil(maxX);
      } else if (typeof renderedStart === 'number' && typeof renderedEnd === 'number') {
        x0 = renderedStart;
        x1 = renderedEnd;
      } else {
        x0 = 0;
        x1 = totalTraces - 1;
      }

      x0 = Math.max(0, Math.floor(x0));
      x1 = Math.min(totalTraces - 1, Math.ceil(x1));
      if (x1 < x0) [x0, x1] = [x1, x0];

      const spanX = Math.max(1, x1 - x0 + 1);
      const padX = (!forceFullExtentOnce && !!savedXRange)
        ? Math.max(1, Math.floor(spanX * 0.5))
        : 0;
      x0 = Math.max(0, x0 - padX);
      x1 = Math.min(totalTraces - 1, x1 + padX);

      // Y range
      const dtBase = window.defaultDt ?? defaultDt;
      let yMinSec, yMaxSec;
      if (!forceFullExtentOnce && savedYRange && savedYRange.length === 2) {
        yMinSec = Math.min(savedYRange[0], savedYRange[1]);
        yMaxSec = Math.max(savedYRange[0], savedYRange[1]);
      } else {
        yMinSec = 0;
        yMaxSec = (totalSamples - 1) * dtBase;
      }

      let y0 = Math.floor(yMinSec / dtBase);
      let y1 = Math.ceil(yMaxSec / dtBase);
      y0 = Math.max(0, y0);
      y1 = Math.min(totalSamples - 1, y1);
      if (y1 < y0) [y0, y1] = [y1, y0];

      const spanY = Math.max(1, y1 - y0 + 1);
      const padY = (!forceFullExtentOnce && !!savedYRange)
        ? Math.max(1, Math.floor(spanY * 0.1))
        : 0;
      y0 = Math.max(0, y0 - padY);
      y1 = Math.min(totalSamples - 1, y1 + padY);

      // one-shot full-extent is consumed here
      if (forceFullExtentOnce) forceFullExtentOnce = false;

      return {
        x0, x1, y0, y1,
        nTraces: x1 - x0 + 1,
        nSamples: y1 - y0 + 1,
      };
    }

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

    async function fetchKey1Values() {
      const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
      if (res.ok) {
        const data = await res.json();
        key1Values = data.values;
        setKey1SliderMax(key1Values.length - 1);
        document.getElementById('key1_idx_display').min = key1Values[0];
        document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
        document.getElementById('key1_idx_slider').value = 0;
        updateKey1Display();
      }
    }

    function prefetchAround(centerIdx, mode) {
      if (mode === 'fbprob') return;
      const effectiveMode = mode === 'auto' ? 'raw' : mode;
      if (effectiveMode !== 'raw') return;
      for (const ctrl of inflight.values()) ctrl.abort();
      inflight.clear();
      const start = Math.max(0, centerIdx - PREFETCH_WIDTH);
      const end = Math.min(key1Values.length - 1, centerIdx + PREFETCH_WIDTH);
      const scheduler = cb => { ('requestIdleCallback' in window) ? requestIdleCallback(cb) : setTimeout(cb, 0); };
      for (let i = start; i <= end; i++) {
        if (i === centerIdx) continue;
        const key1Val = key1Values[i];
        const rawKey = cacheKey(key1Val, 'raw');
        if (cache.has(rawKey) || inflight.has(rawKey)) continue;
        const controller = new AbortController();
        inflight.set(rawKey, controller);
        scheduler(async () => {
          try {
            const urlRaw = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
            const res = await fetch(urlRaw, { signal: controller.signal });
            if (!res.ok) return;
            const bin = new Uint8Array(await res.arrayBuffer());
            const obj = msgpack.decode(bin);
            applyServerDt(obj);
            const int8 = new Int8Array(obj.data.buffer);
            const f32 = Float32Array.from(int8, v => v / obj.scale);
            putCacheF32(rawKey, f32);
            if (!sectionShape) sectionShape = obj.shape;
          } catch (err) {
            if (err.name !== 'AbortError') console.warn('Prefetch failed', key1Val, err);
          } finally {
            inflight.delete(rawKey);
          }
        });
      }
    }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchPicks();
        await fetchAndPlot();
      }
    }

    async function fetchPicks() {
      if (!currentFileId) return;
      const idx = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[idx];
      try {
        const res = await fetch(`/picks?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`);
        if (res.ok) {
          const data = await res.json();
          picks = (data.picks || []).map(p => ({ trace: p.trace, time: p.time }));
        }
      } catch (e) { console.error('Failed to fetch picks', e); }
    }

    async function postPick(trace, time) {
      const idx = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[idx];
      try {
        await fetch('/picks', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file_id: currentFileId, trace, time, key1_idx: key1Val, key1_byte: currentKey1Byte })
        });
      } catch (e) { console.error('Failed to post pick', e); }
    }

    async function deletePick(trace) {
      const idx = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[idx];
      try {
        await fetch(`/picks?file_id=${currentFileId}&trace=${trace}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`, { method: 'DELETE' });
      } catch (e) { console.error('Failed to delete pick', e); }
    }

    async function fetchAndPlot() {
      console.log('--- fetchAndPlot start ---');
      console.time('Total fetchAndPlot');

      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];

      // ★ FB予測キャッシュ取得：レイヤ＆パイプラインキーでキー統一
      const layerCur = (document.getElementById('layerSelect')?.value) || 'raw';
      const pKeyCur = window.latestPipelineKey || null;
      predictedPicks = fbPredCache.get(fbCacheKey(key1Val, layerCur, pKeyCur)) || [];

      await fetchPicks();

      console.time('Cache lookup');
      const hit = getCacheF32(cacheKey(key1Val, 'raw'));
      console.timeEnd('Cache lookup');

      let traces;
      let f32 = hit ? hit.f32 : null;

      if (f32) {
        console.time('Decode from cache');
        const [nTraces, nSamples] = sectionShape;
        traces = new Array(nTraces);
        for (let i = 0; i < nTraces; i++) {
          traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
        }
        console.timeEnd('Decode from cache');
        rawSeismicData = traces;
      } else {
        console.time('Fetch binary');
        const urlRaw = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
        const res = await fetch(urlRaw);
        if (!res.ok) {
          console.timeEnd('Fetch binary');
          alert('Failed to load section');
          return;
        }
        const bin = new Uint8Array(await res.arrayBuffer());
        console.timeEnd('Fetch binary');

        console.time('Decode & cache');
        const obj = msgpack.decode(bin);
        applyServerDt(obj);
        const int8 = new Int8Array(obj.data.buffer);
        f32 = Float32Array.from(int8, (v) => v / obj.scale);
        putCacheF32(cacheKey(key1Val, 'raw'), f32);
        sectionShape = obj.shape;
        const [nTraces, nSamples] = sectionShape;
        traces = new Array(nTraces);
        for (let i = 0; i < nTraces; i++) {
          traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
        }
        console.timeEnd('Decode & cache');
        rawSeismicData = traces;
      }

      latestWindowRender = null;
      windowFetchToken += 1;
      uiResetNonce++;
      if (window.pipelineUI && typeof window.pipelineUI.prepareForNewSection === 'function') {
        window.pipelineUI.prepareForNewSection();
      } else {
        latestTapData = {};
        latestPipelineKey = null;
        const sel = document.getElementById('layerSelect');
        if (sel) {
          sel.innerHTML = '';
          sel.appendChild(new Option('raw', 'raw'));
          sel.value = 'raw';
        }
      }

      const totalTraces = rawSeismicData ? rawSeismicData.length : (sectionShape ? sectionShape[0] : 0);
      const [s, e] = totalTraces > 0
        ? (savedXRange ? visibleTraceIndices(savedXRange, totalTraces) : [0, totalTraces - 1])
        : [0, 0];
      drawSelectedLayer(s, e);

      // Pipeline execution: manual via ▶ Run button

      console.time('Prefetch');
      prefetchAround(index, 'raw');
      console.timeEnd('Prefetch');

      console.timeEnd('Total fetchAndPlot');
      console.log('--- fetchAndPlot end ---');
    }

    function shouldPreferWindowFirst() {
      const win = currentVisibleWindow();
      const plotDiv = document.getElementById('plot');
      if (!win || !plotDiv) return false;
      const { step_x, step_y } = computeStepsForWindow({
        tracesVisible: win.nTraces,
        samplesVisible: win.nSamples,
        widthPx: plotDiv.clientWidth || 1,
        heightPx: plotDiv.clientHeight || 1,
      });
      return (step_x > 1 || step_y > 1);
    }

    function drawSelectedLayer(start = null, end = null) {
      const sel = document.getElementById('layerSelect');
      const layer = sel ? sel.value : 'raw';
      latestSeismicData = (layer === 'raw') ? rawSeismicData : (latestTapData[layer] || null);

      if (shouldPreferWindowFirst()) {
        // 最初からウィンドウ版に任せる（フル描画をスキップ）
        latestSeismicData = null;
        renderLatestView();      // 既存：必要なら状態維持（スピナー等を出すならここ）
        fetchWindowAndPlot();    // 即時フェッチ
        return;
      }

      // 低負荷なら従来どおりフル描画
      const total = latestSeismicData ? latestSeismicData.length : (sectionShape ? sectionShape[0] : 0);
      const s = (typeof start === 'number') ? start : 0;
      const e = (typeof end === 'number') ? end : Math.max(0, total - 1);
      if (latestSeismicData) {
        plotSeismicData(latestSeismicData, defaultDt, s, e);
      } else {
        renderLatestView();
      }
      scheduleWindowFetch();
    }

    function renderWindowWiggle(windowData) {
      if (isRelayouting) {           // ユーザーがドラッグ中
          latestWindowRender = windowData; // 最新結果だけ覚えて
          redrawPending = true;            // 終了後に再描画
          return;
        }
      snapshotAxesRangesFromDOM();
      if (!windowData || (windowData.mode && windowData.mode !== 'wiggle')) return;

      const sel = document.getElementById('layerSelect');
      const currentLayer = sel ? sel.value : 'raw';
      if (windowData.requestedLayer !== currentLayer) return;

      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];
      if (windowData.key1 !== key1Val) return;

      if (windowData.pipelineKey && (window.latestPipelineKey || null) !== (windowData.pipelineKey || null)) {
        return;
      }

      if (windowData.effectiveLayer === 'fbprob') return;

      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;

      const { values, shape, x0, x1, y0, y1, stepX = 1, stepY = 1 } = windowData;
      const rows = Number(shape?.[0] ?? 0);
      const cols = Number(shape?.[1] ?? 0);
      if (!rows || !cols) return;
      if (values.length !== rows * cols) return;

      setGrid({ x0, stepX: 1, y0, stepY: 1 });
      const dt = window.defaultDt ?? defaultDt;
      const time = new Float32Array(rows);
      for (let r = 0; r < rows; r++) time[r] = (y0 + r * stepY) * dt;

      const traces = [];
      const gain = parseFloat(document.getElementById('gain').value) || 1.0;
      const AMP_LIMIT = 3.0;

      for (let c = 0; c < cols; c++) {
        const baseX = new Float32Array(rows);
        const shiftedFullX = new Float32Array(rows);
        const shiftedPosX = new Float32Array(rows);
        const traceIndex = x0 + c * stepX;
        for (let r = 0; r < rows; r++) {
          const idxVal = r * cols + c;
          let val = values[idxVal] * gain;
          if (val > AMP_LIMIT) val = AMP_LIMIT;
          if (val < -AMP_LIMIT) val = -AMP_LIMIT;

          baseX[r] = traceIndex;
          shiftedFullX[r] = traceIndex + val;
          shiftedPosX[r] = traceIndex + (val < 0 ? 0 : val);
        }

        traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'skip', showlegend: false });
        traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
        traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, hoverinfo: 'x+y', showlegend: false });
      }

      downsampleFactor = 1;
      const endTrace = typeof x1 === 'number' ? x1 : x0 + cols - 1;
      renderedStart = x0;
      renderedEnd = endTrace;

      const totalTraces = sectionShape ? sectionShape[0] : endTrace - x0 + 1;
      const totalSamples = sectionShape ? sectionShape[1] : (typeof y1 === 'number' ? y1 - y0 + 1 : rows);
      const layout = buildLayout({
        mode: 'wiggle',
        x0,
        x1: endTrace,
        y0,
        y1,
        stepX: 1,
        stepY: 1,
        totalSamples,
        dt,
        savedXRange,
        savedYRange,
        clickmode: clickModeForCurrentState(),
        dragmode: effectiveDragMode(),
        uirevision: currentUiRevision(),
        fbTitle: null,
      });

      const showPred = !!document.getElementById('showFbPred')?.checked;
      layout.shapes = buildPickShapes({
        manualPicks: picks,
        predicted: showPred ? predictedPicks : [],
        xMin: x0,
        xMax: endTrace,
        showPredicted: showPred,
      });

      withSuppressedRelayout(Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: true,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false },
      }));
      setTimeout(() => {
          withSuppressedRelayout(Plotly.Plots.resize(plotDiv));
        }, 50);
      requestAnimationFrame(applyDragMode);
      installPlotlyViewportHandlersOnce();
      attachPickListeners(plotDiv);
    }

    function renderWindowHeatmap(windowData) {
      if (isRelayouting) {           // ユーザーがドラッグ中
          latestWindowRender = windowData; // 最新結果だけ覚えて
          redrawPending = true;            // 終了後に再描画
          return;
        }
      snapshotAxesRangesFromDOM();
      if (!windowData || (windowData.mode && windowData.mode !== 'heatmap')) return;
      const sel = document.getElementById('layerSelect');
      const currentLayer = sel ? sel.value : 'raw';
      if (windowData.requestedLayer !== currentLayer) return;

      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];
      if (windowData.key1 !== key1Val) return;

      if (windowData.pipelineKey && (window.latestPipelineKey || null) !== (windowData.pipelineKey || null)) {
        return;
      }

      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;

      const { values, shape, x0, x1, y0, y1, stepX, stepY, effectiveLayer } = windowData;
      const rows = Number(shape?.[0] ?? 0);
      const cols = Number(shape?.[1] ?? 0);
      if (!rows || !cols) return;
      if (values.length !== rows * cols) return;

      setGrid({ x0, stepX, y0, stepY });
      const gain = parseFloat(document.getElementById('gain').value) || 1.0;
      const AMP_LIMIT = 3.0;
      const fbMode = effectiveLayer === 'fbprob';
      const zData = new Array(rows);
      for (let r = 0; r < rows; r++) {
        const row = new Float32Array(cols);
        const offset = r * cols;
        for (let c = 0; c < cols; c++) {
          let val = values[offset + c];
          if (fbMode) {
            row[c] = val * 255;
          } else {
            val *= gain;
            if (val > AMP_LIMIT) val = AMP_LIMIT;
            else if (val < -AMP_LIMIT) val = -AMP_LIMIT;
            row[c] = val;
          }
        }
        zData[r] = row;
      }

      const xVals = new Float32Array(cols);
      for (let c = 0; c < cols; c++) xVals[c] = x0 + c * stepX;

      const baseDt = window.defaultDt ?? defaultDt;
      const yVals = new Float32Array(rows);
      for (let r = 0; r < rows; r++) yVals[r] = (y0 + r * stepY) * baseDt;

      downsampleFactor = stepY || 1;
      renderedStart = x0;
      renderedEnd = x1;

      const cmName = document.getElementById('colormap')?.value || 'Greys';
      const reverse = document.getElementById('cmReverse')?.checked || false;
      const cm = COLORMAPS[cmName] || 'Greys';
      const isDiv = cmName === 'RdBu' || cmName === 'BWR';
      const zMin = fbMode ? 0 : -AMP_LIMIT;
      const zMax = fbMode ? 255 : AMP_LIMIT;

      const traces = [{
        type: 'heatmap',
        x: xVals,
        y: yVals,
        z: zData,
        colorscale: cm,
        reversescale: reverse,
        zmin: zMin,
        zmax: zMax,
        ...(fbMode ? {} : (isDiv ? { zmid: 0 } : {})),
        showscale: false,
        hoverinfo: 'x+y',
        hovertemplate: '',
      }];

      const dt = window.defaultDt ?? defaultDt;
      const layout = buildLayout({
        mode: 'heatmap',
        x0,
        x1,
        y0,
        y1,
        stepX,
        stepY,
        totalSamples: sectionShape ? sectionShape[1] : (y1 - y0 + 1),
        dt,
        savedXRange,
        savedYRange,
        clickmode: clickModeForCurrentState(),
        dragmode: effectiveDragMode(),
        uirevision: currentUiRevision(),
        fbTitle: fbMode ? 'First-break Probability' : null,
      });

      const showPred = !!document.getElementById('showFbPred')?.checked;
      layout.shapes = buildPickShapes({
        manualPicks: picks,
        predicted: showPred ? predictedPicks : [],
        xMin: x0,
        xMax: x1,
        showPredicted: showPred,
      });

      withSuppressedRelayout(Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: true,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false },
      }));
      setTimeout(() => {
          withSuppressedRelayout(Plotly.Plots.resize(plotDiv));
        }, 50);
      requestAnimationFrame(applyDragMode);
      installPlotlyViewportHandlersOnce();
      attachPickListeners(plotDiv);
    }
    function renderLatestView(startOverride = null, endOverride = null) {
      const sel = document.getElementById('layerSelect');
      const layer = sel ? sel.value : 'raw';
      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];

      if (latestSeismicData) {
        const startTrace = typeof startOverride === 'number'
          ? startOverride
          : (typeof renderedStart === 'number' ? renderedStart : 0);
        const endTrace = typeof endOverride === 'number'
          ? endOverride
          : (typeof renderedEnd === 'number'
            ? renderedEnd
            : latestSeismicData.length - 1);
        plotSeismicData(latestSeismicData, defaultDt, startTrace, endTrace);
        return;
      }

      if (
        latestWindowRender &&
        latestWindowRender.requestedLayer === layer &&
        latestWindowRender.key1 === key1Val
      ) {
        if (layer !== 'raw') {
          const pipelineKeyNow = window.latestPipelineKey || null;
          if ((latestWindowRender.pipelineKey || null) !== (pipelineKeyNow || null)) {
            return;
          }
        }
        if (latestWindowRender.mode === 'wiggle') {
          renderWindowWiggle(latestWindowRender);
        } else {
          renderWindowHeatmap(latestWindowRender);
        }
      }
    }

    async function fetchWindowAndPlot() {
      if (!currentFileId || !sectionShape) return;
      const slider = document.getElementById('key1_idx_slider');
      if (!slider) return;
      const idx = parseInt(slider.value, 10);
      const key1Val = key1Values[idx];
      if (key1Val === undefined) return;

      const windowInfo = currentVisibleWindow();
      if (!windowInfo) return;

      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;

      const widthPx = plotDiv.clientWidth || plotDiv.offsetWidth || 1;
      const heightPx = plotDiv.clientHeight || plotDiv.offsetHeight || 1;
      const sel = document.getElementById('layerSelect');
      const requestedLayer = sel ? sel.value : 'raw';
      const isFbLayer = requestedLayer === 'fbprob';
      const wantWiggle = !isFbLayer && wantWiggleForWindow({
        tracesVisible: windowInfo.nTraces,
        samplesVisible: windowInfo.nSamples,
        widthPx,
      });

      let step_x, step_y;
      if (wantWiggle) {
        step_x = 1; step_y = 1;
      } else {
        ({ step_x, step_y } = computeStepsForWindow({
          tracesVisible: windowInfo.nTraces,
          samplesVisible: windowInfo.nSamples,
          widthPx,
          heightPx,
        }));
      }

      const pipelineKeyNow = window.latestPipelineKey || null;
      const mode = wantWiggle ? 'wiggle' : 'heatmap';

      let effectiveLayer = requestedLayer;
      let tapLabel = null;
      if (requestedLayer !== 'raw') {
        if (pipelineKeyNow) {
          tapLabel = requestedLayer;
        } else {
          effectiveLayer = 'raw';
        }
      } else {
        effectiveLayer = 'raw';
      }

      if (!wantWiggle && effectiveLayer === 'raw' && latestSeismicData && step_x === 1 && step_y === 1) {
        return;
      }
      if (!wantWiggle && tapLabel && latestTapData[requestedLayer] && step_x === 1 && step_y === 1) {
        latestSeismicData = latestTapData[requestedLayer];
        renderLatestView(windowInfo.x0, windowInfo.x1);
        return;
      }

      const params = new URLSearchParams({
        file_id: currentFileId,
        key1_idx: String(key1Val),
        key1_byte: String(currentKey1Byte),
        key2_byte: String(currentKey2Byte),
        x0: String(windowInfo.x0),
        x1: String(windowInfo.x1),
        y0: String(windowInfo.y0),
        y1: String(windowInfo.y1),
        step_x: String(step_x),
        step_y: String(step_y),
      });
      if (tapLabel && pipelineKeyNow) {
        params.set('pipeline_key', pipelineKeyNow);
        params.set('tap_label', tapLabel);
      }

      const requestId = ++windowFetchToken;

      // ---- Abort older in-flight window fetch, then create a new controller
      if (windowFetchCtrl) {
        try { windowFetchCtrl.abort(); } catch (_) { }
      }
      const ctrl = new AbortController();
      windowFetchCtrl = ctrl;

      try {
        const res = await fetch(`/get_section_window_bin?${params.toString()}`, { signal: ctrl.signal });
        if (!res.ok) {
          console.warn('Window fetch failed', res.status);
          return;
        }
        const bin = new Uint8Array(await res.arrayBuffer());
        if (requestId !== windowFetchToken) return; // stale
        const obj = msgpack.decode(bin);
        applyServerDt(obj);
        const int8 = new Int8Array(obj.data.buffer);
        const values = Float32Array.from(int8, (v) => v / obj.scale);
        const shapeRaw = Array.isArray(obj.shape) ? obj.shape : Array.from(obj.shape ?? []);
        if (shapeRaw.length !== 2) {
          console.warn('Unexpected window shape', obj.shape);
          return;
        }
        const rows = Number(shapeRaw[0]);
        const cols = Number(shapeRaw[1]);
        const windowPayload = {
          key1: key1Val,
          requestedLayer,
          effectiveLayer,
          pipelineKey: tapLabel ? pipelineKeyNow : null,
          x0: windowInfo.x0,
          x1: windowInfo.x1,
          y0: windowInfo.y0,
          y1: windowInfo.y1,
          stepX: step_x,
          stepY: step_y,
          shape: [rows, cols],
          values,
          mode,
        };
        latestSeismicData = null;
        latestWindowRender = windowPayload;
        if (isRelayouting) {      // ドラッグ中なら描画は保留
            redrawPending = true;
            return;
          }
        if (mode === 'wiggle') renderWindowWiggle(windowPayload);
        else renderWindowHeatmap(windowPayload);
      } catch (err) {
        if (err && err.name === 'AbortError') {
          // canceled on purpose; ignore
          return;
        }
        if (requestId === windowFetchToken) console.warn('Window fetch error', err);
      } finally {
        if (windowFetchCtrl === ctrl) windowFetchCtrl = null;
      }
    }

    const scheduleWindowFetch = debounce(() => {
      fetchWindowAndPlot().catch((err) => console.warn('Window fetch failed', err));
    }, WINDOW_FETCH_DEBOUNCE_MS);

    function visibleTraceIndices(range, total) {
      let start = Math.floor(range[0]);
      let end = Math.ceil(range[1]);
      start = Math.max(0, start);
      end = Math.min(total - 1, end);
      return [start, end];
    }

    function clickModeForCurrentState() {
        return isPickMode ? 'event' : 'event+select';
      }

    function plotSeismicData(seismic, dt, startTrace = 0, endTrace = seismic.length - 1) {
      snapshotAxesRangesFromDOM();
      const totalTraces = seismic.length;
      startTrace = Math.max(0, startTrace);
      endTrace = Math.min(totalTraces - 1, endTrace);
      const nTraces = endTrace - startTrace + 1;
      const nSamples = seismic[0].length;
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, totalTraces - 1];
      const visibleTraces = endTrace - startTrace + 1;
      const density = visibleTraces / widthPx;
      const mode = document.getElementById('layerSelect').value;
      const fbMode = mode === 'fbprob'; // 使っていないが残置可

      let traces = [];
      const gain = parseFloat(document.getElementById('gain').value) || 1.0;
      const AMP_LIMIT = 3.0;
      let defaultXRange;
      let defaultYRange;

      if (!fbMode && density < WIGGLE_DENSITY_THRESHOLD) {
        downsampleFactor = 1;
        setGrid({ x0: startTrace, stepX: 1, y0: 0, stepY: 1 });
        const time = new Float32Array(nSamples);
        for (let t = 0; t < nSamples; t++) time[t] = t * dt;
        for (let i = startTrace; i <= endTrace; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            let val = raw[j] * gain;
            if (val > AMP_LIMIT) val = AMP_LIMIT;
            if (val < -AMP_LIMIT) val = -AMP_LIMIT;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'x+y', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, hoverinfo: 'skip', showlegend: false });
        }
        defaultXRange = [startTrace, endTrace];
        defaultYRange = [nSamples * dt, 0];
      } else {
        const MAX_POINTS = 3_000_000;
        let factor = 1;
        while (Math.floor(nTraces / factor) * Math.floor(nSamples / factor) > MAX_POINTS) factor++;
        const nTracesDS = Math.floor(nTraces / factor);
        const nSamplesDS = Math.floor(nSamples / factor);
        console.log('Downsampling factor:', factor);
        console.log('Final dimensions:', nTracesDS, 'x', nSamplesDS);

        setGrid({ x0: startTrace, stepX: factor, y0: 0, stepY: factor });
        const time = new Float32Array(nSamplesDS);
        for (let t = 0; t < nSamplesDS; t++) time[t] = t * dt * factor;

        const zData = Array.from({ length: nSamplesDS }, () => new Float32Array(nTracesDS));

        for (let i = startTrace, col = 0; col < nTracesDS; i += factor, col++) {
          const trace = seismic[i];
          for (let j = 0, row = 0; row < nSamplesDS; j += factor, row++) {
            if (fbMode) {
              const val = trace[j] * 255;
              zData[row][col] = val;
            } else {
              let val = trace[j] * gain;
              if (val > AMP_LIMIT) val = AMP_LIMIT;
              if (val < -AMP_LIMIT) val = -AMP_LIMIT;
              zData[row][col] = val;
            }
          }
        }

        const zMin = fbMode ? 0 : -AMP_LIMIT;
        const zMax = fbMode ? 255 : AMP_LIMIT;

        const xVals = new Float32Array(nTracesDS);
        for (let i = 0; i < nTracesDS; i++) xVals[i] = startTrace + i * factor;
        downsampleFactor = factor;

        const cmName = document.getElementById('colormap')?.value || 'Greys';
        const reverse = document.getElementById('cmReverse')?.checked || false;
        const cm = COLORMAPS[cmName] || 'Greys';
        const isDiv = cmName === 'RdBu' || cmName === 'BWR';

        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: cm,
          reversescale: reverse,
          zmin: zMin,
          zmax: zMax,
          ...(fbMode ? {} : (isDiv ? { zmid: 0 } : {})),
          showscale: false,
          hoverinfo: 'x+y',
          hovertemplate: '',
        }];
        const halfX = factor * 0.5;
        const halfY = dt * factor * 0.5;
        defaultXRange = [startTrace - halfX, (startTrace + (nTracesDS - 1) * factor) + halfX];
        defaultYRange = [ (nSamplesDS * dt * factor) - halfY, 0 - halfY ];
      }

      const layout = {
        xaxis: {
          title: 'Trace', showgrid: false, tickfont: { color: '#000' }, titlefont: { color: '#000' },
          autorange: false, range: savedXRange ?? defaultXRange
        },
        yaxis: {
          title: 'Time (s)', showgrid: false, tickfont: { color: '#000' }, titlefont: { color: '#000' },
          autorange: false, range: savedYRange ?? defaultYRange
        },
        clickmode: clickModeForCurrentState(),
        uirevision: currentUiRevision(),
        paper_bgcolor: '#fff', plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: effectiveDragMode(),
        ...(fbMode ? { title: 'First-break Probability' } : {}),
      };

      const manualShapes = picks.map(p => ({
        type: 'line',
        x0: p.trace - 0.4, x1: p.trace + 0.4,
        y0: p.time, y1: p.time,
        line: { color: 'red', width: 2 }
      }));

      const showPred = document.getElementById('showFbPred')?.checked;
      const predShapes = (showPred ? predictedPicks : [])
        .filter(p => p.trace >= startTrace && p.trace <= endTrace)
        .map(p => ({
          type: 'line',
          x0: p.trace - 0.4, x1: p.trace + 0.4,
          y0: p.time, y1: p.time,
          line: { color: '#1f77b4', width: 5, dash: 'dot' }
        }));

      layout.shapes = [...manualShapes, ...predShapes];

      withSuppressedRelayout(Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: true,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false }
      }));
      setTimeout(() => {
          withSuppressedRelayout(Plotly.Plots.resize(plotDiv));
        }, 50);
      requestAnimationFrame(applyDragMode);
      renderedStart = startTrace;
      renderedEnd = endTrace;
      console.log(`Rendered traces ${startTrace}-${endTrace}`);
      installPlotlyViewportHandlersOnce();
      attachPickListeners(plotDiv);
    }

    function pickOnTrace(trace) {
      return picks.findIndex(p => Math.round(p.trace) === trace);
    }

    async function handlePickNormalized({ trace, time, shiftKey, ctrlKey, altKey }) {
      if (isPickMode && dragOverride === 'pan') return;
      if (!Number.isFinite(trace) || !Number.isFinite(time)) return;

      if (handlePickNormalized._busy) {
        handlePickNormalized._queued = { trace, time, shiftKey, ctrlKey, altKey };
        return;
      }
      handlePickNormalized._busy = true;

      try {
        if (!isPickMode) return;

        console.log('🔥 pick request', { trace, time, shiftKey, ctrlKey, altKey });

        if (ctrlKey) {
          if (deleteRangeStart === null) {
            deleteRangeStart = trace;
            linePickStart = null;
            return;
          }
          const x0 = deleteRangeStart;
          deleteRangeStart = null;
          const x1 = trace;
          const start = Math.min(x0, x1);
          const end = Math.max(x0, x1);
          const toDelete = picks.filter(p => Math.round(p.trace) >= start && Math.round(p.trace) <= end);
          const promises = toDelete.map(p => deletePick(Math.round(p.trace)));
          picks = picks.filter(p => Math.round(p.trace) < start || Math.round(p.trace) > end);
          await Promise.all(promises);
          setTimeout(() => {
            try { renderLatestView(); } catch (e) { console.warn('renderLatestView failed', e); }
          }, 0);
          return;
        }

        if (shiftKey) {
          if (!linePickStart) {
            linePickStart = { trace, time };
            deleteRangeStart = null;
            return;
          }

          const { trace: x0, time: y0 } = linePickStart;
          linePickStart = { trace, time };
          const x1 = trace;
          const y1 = time;
          const xStart = Math.round(Math.min(x0, x1));
          const xEnd = Math.round(Math.max(x0, x1));
          const slope = x1 === x0 ? 0 : (y1 - y0) / (x1 - x0);

          const promises = [];
          for (let x = xStart; x <= xEnd; x++) {
            const y = x1 === x0 ? y1 : y0 + slope * (x - x0);
            const snapped = snapTimeFromDataY(y);
            const tAdj = adjustPickToFeature(x, snapped);

            const idx = pickOnTrace(x);
            if (idx >= 0) {
              promises.push(deletePick(x));
              picks.splice(idx, 1);
            }
            picks.push({ trace: x, time: tAdj });
            promises.push(postPick(x, tAdj));
          }
          await Promise.all(promises);
          renderLatestView();
          return;
        }

        linePickStart = null;
        deleteRangeStart = null;

        const idx = pickOnTrace(trace);
        const promises = [];
        if (idx >= 0) {
          promises.push(deletePick(trace));
          picks.splice(idx, 1);
        }
        const tAdj = adjustPickToFeature(trace, time);
        picks.push({ trace, time: tAdj });
        promises.push(postPick(trace, tAdj));
        await Promise.all(promises);
        renderLatestView();
      } finally {
        handlePickNormalized._busy = false;
        const next = handlePickNormalized._queued;
        handlePickNormalized._queued = null;
        if (next) setTimeout(() => handlePickNormalized(next), 0);
      }
    }

    async function handlePlotClick(ev) {
      const p0 = ev?.points?.[0];
      const raw = ev?.event;
      if (!p0 || !raw) {
        console.warn('⚠️ plotly_click payload missing point/event');
        return;
      }

      const trace = snapTraceFromDataX(p0.x);
      const time = snapTimeFromDataY(p0.y);
      if (!Number.isFinite(trace) || !Number.isFinite(time)) return;

      await handlePickNormalized({
        trace,
        time,
        shiftKey: !!raw.shiftKey,
        ctrlKey: !!raw.ctrlKey,
        altKey: !!raw.altKey,
      });
    }

    async function handleRelayout(ev) {
      if (suppressRelayout) return;
      const plotDiv = document.getElementById('plot');
      if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
        savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
      }

      if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
        const y0 = ev['yaxis.range[0]'];
        const y1 = ev['yaxis.range[1]'];
        savedYRange = y0 > y1 ? [y0, y1] : [y1, y0];
      }

      if (Array.isArray(ev.shapes)) {
        // 予測(青点線)は保存しない。赤のみ保存。
        const onlyManual = ev.shapes.filter(s => s.line && s.line.color === 'red');
        const newPicks = onlyManual.map(s => ({
          trace: (s.x0 + s.x1) / 2,
          time: (s.y0 + s.y1) / 2
        }));

        const oldTraces = new Set(picks.map(p => Math.round(p.trace)));
        const newTraces = new Set(newPicks.map(p => Math.round(p.trace)));
        for (const t of oldTraces) {
          if (!newTraces.has(t)) {
            await deletePick(t);
          }
        }
        picks = newPicks;
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      const overlay = document.getElementById('ppOverlay');
      const statusEl = document.getElementById('ppStatus');
      const barInner = document.getElementById('ppBarInner');
      const cancelBtn = document.getElementById('ppCancelBtn');

      if (!overlay || !statusEl || !barInner || !cancelBtn) {
        return;
      }

      let totalStepsCount = 1;

      function setText(msg) {
        statusEl.textContent = msg || '';
      }

      function setProgress(pct) {
        const clamped = Math.max(0, Math.min(100, Math.round(pct)));
        barInner.style.width = `${clamped}%`;
      }

      function openOverlay(totalSteps = 1, initialText = 'Preparing…') {
        totalStepsCount = Math.max(1, Number(totalSteps) || 1);
        overlay.classList.add('show');
        setText(initialText);
        setProgress(0);
      }

      function stepOverlay(index, name) {
        const idx = Math.max(0, Number(index) || 0);
        const pct = Math.round((idx / totalStepsCount) * 100);
        const label = name ? `(${idx}/${totalStepsCount}) ${name}` : `Step ${idx}/${totalStepsCount}`;
        setText(label);
        setProgress(pct);
      }

      function closeOverlay() {
        overlay.classList.remove('show');
      }

      function errorOverlay(message) {
        setText(`Error: ${message}`);
        setProgress(100);
        setTimeout(() => closeOverlay(), 1200);
      }

      const progressApi = {
        open: openOverlay,
        progress: setProgress,
        step: stepOverlay,
        text: setText,
        close: closeOverlay,
        error: errorOverlay,
      };

      window.pipelineProgress = progressApi;

      cancelBtn.addEventListener('click', () => {
        try {
          if (window.pipelineUI && typeof window.pipelineUI.cancel === 'function') {
            window.pipelineUI.cancel();
          }
        } catch (err) {
          console.warn('pipeline cancel threw', err);
        }
        closeOverlay();
      });

      function attachPipelineHandlers() {
        const ui = window.pipelineUI;
        if (!ui) return;

        if (typeof ui.on === 'function') {
          ui.on('run:start', (event) => {
            const total = event && typeof event.totalSteps === 'number' ? event.totalSteps : 1;
            openOverlay(total, 'Submitting…');
          });
          ui.on('run:step', (event) => {
            const idx = event && typeof event.index === 'number' ? event.index : 0;
            const name = event && typeof event.name === 'string' ? event.name : 'Processing…';
            stepOverlay(idx, name);
          });
          ui.on('run:finish', (event) => {
            const total = event && typeof event.totalSteps === 'number' ? event.totalSteps : totalStepsCount;
            stepOverlay(total, 'Done');
            setTimeout(() => closeOverlay(), 400);
          });
          ui.on('run:error', (event) => {
            const message = event && typeof event.message === 'string' ? event.message : 'failed';
            errorOverlay(message);
          });
          return;
        }

        if (typeof ui.run === 'function' && !ui.__progressWrapped) {
          const originalRun = ui.run.bind(ui);
          ui.__progressWrapped = true;
          ui.run = async function progressWrappedRun(...args) {
            openOverlay(1, 'Running pipeline…');
            try {
              const result = await originalRun(...args);
              setProgress(100);
              setTimeout(() => closeOverlay(), 400);
              return result;
            } catch (err) {
              errorOverlay((err && err.message) || 'failed');
              throw err;
            }
          };
        }
      }

      attachPipelineHandlers();
    });

    window.addEventListener('DOMContentLoaded', loadSettings);

    // Toggle between raw and first tap with the "n" key
    window.addEventListener('keydown', (e) => {
      if (
        e.key.toLowerCase() === 'n' &&
        !e.ctrlKey && !e.altKey && !e.metaKey &&
        !['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)
      ) {
        const sel = document.getElementById('layerSelect');
        if (!sel) return;
        if (sel.options.length > 1) {
          sel.value = sel.value === 'raw' ? sel.options[1].value : 'raw';
          drawSelectedLayer();
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'Shift') {
        linePickStart = null;
      }
    });
  </script>
  <div id="ppOverlay">
    <div class="ppCard">
      <div class="ppTitle">Pipeline running…</div>
      <div id="ppStatus" class="ppStatus">Preparing…</div>
      <div class="ppBar">
        <div id="ppBarInner" class="ppBarInner"></div>
      </div>
      <div class="ppActions">
        <button id="ppCancelBtn" type="button">Cancel</button>
      </div>
    </div>
  </div>
</body>

</html>
