<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Upload SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi-viewport/4.37.0/viewport.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let appPixi = null;
    let viewport = null;
    let savedTransform = null;

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

    function initPixi() {
      const plotDiv = document.getElementById('plot');
      appPixi = new PIXI.Application({
        resizeTo: plotDiv,
        backgroundColor: 0xffffff,
        antialias: true
      });
      plotDiv.appendChild(appPixi.view);
      viewport = new PIXI.Viewport({
        interaction: appPixi.renderer.plugins.interaction,
        screenWidth: plotDiv.clientWidth,
        screenHeight: plotDiv.clientHeight
      });
      viewport.drag().pinch().wheel().decelerate();
      appPixi.stage.addChild(viewport);
    }

    async function fetchKey1Values() {
      const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
      if (res.ok) {
        const data = await res.json();
        key1Values = data.values;
        setKey1SliderMax(key1Values.length - 1);
        document.getElementById('key1_idx_display').min = key1Values[0];
        document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
        document.getElementById('key1_idx_slider').value = 0;
        updateKey1Display();
      }
    }

    async function loadSettings() {
      if (!appPixi) {
        initPixi();
      }
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchAndPlot();
      }
    }

    async function fetchAndPlot() {
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      const url = `/get_section?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
      const res = await fetch(url);
      if (!res.ok) {
        alert('Failed to load section');
        return;
      }
      const json = await res.json();
      plotSeismicData(json.section, 0.004);
    }

    function storeTransform() {
      savedTransform = {
        x: viewport.x,
        y: viewport.y,
        scaleX: viewport.scale.x,
        scaleY: viewport.scale.y
      };
    }

    function plotSeismicData(seismic, dt) {
      viewport.removeChildren();
      const nTraces = seismic.length;
      const nSamples = seismic[0].length;

      viewport.worldWidth = nTraces + 1;
      viewport.worldHeight = nSamples * dt;

      for (let i = 0; i < nTraces; i++) {
        const raw = seismic[i];
        const line = new PIXI.Graphics();
        const fill = new PIXI.Graphics();

        line.lineStyle(1, 0x000000, 1);
        line.moveTo(i, 0);
        fill.beginFill(0x000000, 0.6);
        fill.moveTo(i, 0);

        for (let j = 0; j < nSamples; j++) {
          const val = raw[j];
          const y = j * dt;
          line.lineTo(i + val, y);
          fill.lineTo(i + Math.max(0, val), y);
        }
        fill.lineTo(i, (nSamples - 1) * dt);
        fill.endFill();

        viewport.addChild(fill);
        viewport.addChild(line);
      }

      if (savedTransform) {
        viewport.position.set(savedTransform.x, savedTransform.y);
        viewport.scale.set(savedTransform.scaleX, savedTransform.scaleY);
      } else {
        viewport.fit();
        viewport.moveCorner(0, 0);
      }

      viewport.off('moved', storeTransform);
      viewport.on('moved', storeTransform);
    }


    window.addEventListener('DOMContentLoaded', loadSettings);
  </script>
</body>
</html>
