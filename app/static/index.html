<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />

<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    :root {
      color-scheme: light;
    }

    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #mainContent {
      flex: 1;
      display: flex;
      min-height: 0;
      background: #fff;
    }

    #viewerColumn {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
      display: flex;
      gap: 1em;
      align-items: center;
      flex-wrap: wrap;
      overflow-y: auto;
    }

    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }

    #plot {
      flex: 1;
      width: 100%;
      min-height: 0;
    }

    #pickModeBtn.active {
      background: #007bff;
      color: #fff;
    }

    .denoiseParam {
      display: none;
    }

    .bpfParam {
      display: none;
    }

    #denoiseSettingsDialog {
      padding: 1em;
      border: 1px solid #888;
    }

    #denoiseSettingsDialog form label {
      display: block;
      margin: 0.5em 0;
    }

    #pipelinePanel {
      width: 320px;
      max-width: 100%;
      border-left: 1px solid #ddd;
      background: #fdfdfd;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .pipeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75em 1em;
      border-bottom: 1px solid #ddd;
      background: #f7f7f7;
      font-weight: 600;
    }

    .pipeline-header .pipeline-actions {
      display: inline-flex;
      gap: 0.5em;
      align-items: center;
    }

    .pipeline-add {
      position: relative;
      display: inline-flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .pipeline-add button {
      margin-right: 0;
    }

    .pipeline-add-menu {
      position: absolute;
      top: 100%;
      right: 0;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, .08);
      padding: .25em 0;
      margin-top: .3em;
      display: none;
      min-width: 160px;
      z-index: 20;
    }

    .pipeline-add-menu.open {
      display: block;
    }

    .pipeline-add-menu button {
      display: block;
      width: 100%;
      background: transparent;
      border: 0;
      text-align: left;
      padding: .45em 1em;
      font-size: .95em;
      cursor: pointer;
    }

    .pipeline-add-menu button:hover,
    .pipeline-add-menu button:focus {
      background: #eef3ff;
    }

    #pipelineCards {
      flex: 1;
      overflow-y: auto;
      padding: 1em;
      background: #fafafa;
    }

    .pipeline-card {
      border: 1px solid #d2d2d2;
      border-radius: 8px;
      padding: .75em;
      background: #fff;
      display: flex;
      flex-direction: column;
      gap: .5em;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .04);
    }

    .pipeline-card+.pipeline-card {
      margin-top: .75em;
    }

    .pipeline-card.disabled {
      opacity: .6;
    }

    .pipeline-card.inspecting {
      border-color: #4c8bf5;
      box-shadow: 0 0 0 1px rgba(76, 139, 245, .25);
    }

    .pipeline-card.is-dragging {
      opacity: .6;
    }

    .pipeline-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .5em;
    }

    .pipeline-card-title {
      display: inline-flex;
      align-items: center;
      gap: .4em;
      font-weight: 600;
      font-size: .95em;
    }

    .drag-handle {
      cursor: grab;
      color: #666;
      font-size: 1.1em;
      line-height: 1;
      user-select: none;
    }

    .pipeline-card-controls {
      display: flex;
      flex-wrap: wrap;
      gap: .75em;
      font-size: .85em;
    }

    .pipeline-card-controls label {
      display: inline-flex;
      align-items: center;
      gap: .35em;
      cursor: pointer;
    }

    .pipeline-label {
      display: flex;
      flex-direction: column;
      gap: .3em;
      font-size: .85em;
    }

    .pipeline-label-input {
      font-size: .95em;
      padding: .35em .45em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .pipeline-card button {
      font-size: .85em;
      padding: .35em .6em;
      margin-right: 0;
    }

    .pipeline-empty {
      color: #666;
      font-size: .9em;
      padding: .5em .25em;
      text-align: center;
    }

    .pipeline-inspector {
      border-top: 1px solid #ddd;
      padding: .9em 1em;
      background: #fff;
    }

    .pipeline-inspector.hidden {
      display: none;
    }

    .pipeline-inspector h3 {
      margin: 0 0 .6em 0;
      font-size: 1em;
    }

    .pipeline-inspector form {
      display: flex;
      flex-direction: column;
      gap: .6em;
    }

    .pipeline-inspector label {
      display: flex;
      flex-direction: column;
      gap: .3em;
      font-size: .85em;
    }

    .pipeline-inspector input,
    .pipeline-inspector select {
      font-size: .95em;
      padding: .35em .45em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .pipeline-inspector-actions {
      display: flex;
      justify-content: flex-end;
      gap: .5em;
      margin-top: .4em;
    }

    /* While in pick mode, shapes should not eat clicks */
    .pick-mode .shapelayer path,
    .pick-mode .shapelayer line {
      pointer-events: none;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Open SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="mainContent">
    <div id="viewerColumn">
      <div id="controls">
        <label for="key1_idx_slider">key1 index:</label>
        <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1"
          oninput="updateKey1Display(); fetchAndPlot()" />
        <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;"
          onchange="syncSliderWithInput(); fetchAndPlot()" />
        <button onclick="fetchAndPlot()">Plot</button>
        <button id="pickModeBtn" onclick="togglePickMode()">Pick Mode: OFF</button>
        <select id="layerSelect" onchange="drawSelectedLayer()">
          <option value="raw" selected>raw</option>
        </select>
        <label style="margin-left:8px">σmax (ms):
          <input id="sigma_ms_max" type="number" value="20" step="1" min="1" style="width:5em"
            oninput="onSigmaChange()">
        </label>
        <label style="margin-left:8px">Pick:
          <select id="pick_method" onchange="onPickMethodChange()">
            <option value="argmax" selected>argmax</option>
            <option value="expectation">expectation</option>
          </select>
        </label>
        <label><input type="checkbox" id="showFbPred"
            onchange="localStorage.setItem('showFbPred', this.checked); drawSelectedLayer(renderedStart, renderedEnd)">Show FB
          predicted</label>

        <button id="predictFbBtn" onclick="predictFromFb()">Predict from FB</button>
        <label for="gain">Gain:</label>
        <input type="range" id="gain" min="0.1" max="5" step="0.1" value="1" oninput="onGainChange()" />
        <span id="gain_display">1×</span>
        <select id="denoiseScope">
          <option value="display">表示セクション</option>
          <option value="all_key1">データ全体</option>
          <option value="common_shot">共通ショット</option>
          <option value="common_receiver">共通レシーバー</option>
        </select>
        <button id="openDenoiseDlgBtn" onclick="openDenoiseSettings()">ノイズ抑制パラメータ設定</button>
        <label class="denoiseParam">mask_ratio:<input type="number" id="mask_ratio" value="0.5" step="0.1" min="0"
            max="1" style="width:70px;"></label>
        <label class="denoiseParam">noise_std:<input type="number" id="noise_std" value="1" step="0.1"
            style="width:70px;"></label>
        <label class="denoiseParam">chunk_h:<input type="number" id="chunk_h" value="128" step="1"
            style="width:70px;"></label>
        <label class="denoiseParam">overlap:<input type="number" id="overlap" value="32" step="1"
            style="width:70px;"></label>
        <select id="mask_noise_mode" class="denoiseParam">
          <option value="replace" selected>replace</option>
          <option value="add">add</option>
        </select>
        <button id="denoiseBtn" onclick="handleDenoise()">ノイズ抑制</button>
        <progress id="denoiseProgress" value="0" max="1" style="display:none; width:150px;"></progress>
        <span id="denoiseProgressText"></span>
        <button id="openBpfDlgBtn" onclick="openBpfSettings()">BPFパラメータ設定</button>
        <label class="bpfParam">low_hz:<input type="number" id="low_hz" value="5" step="0.1"
            style="width:70px;"></label>
        <label class="bpfParam">high_hz:<input type="number" id="high_hz" value="60" step="0.1"
            style="width:70px;"></label>
        <label class="bpfParam">dt:<input type="number" id="dt" value="0.002" step="0.0001" style="width:70px;"></label>
        <label class="bpfParam">taper:<input type="number" id="taper" value="0.1" step="0.1"
            style="width:70px;"></label>
        <button id="bpfBtn" onclick="handleBandpass()">BPF（表示セクション）</button>
        <button id="bpfApplyBtn" onclick="applyBandpassBatch()">BPF（全体/共通）</button>
        <label for="colormap">Colormap:</label>
        <select id="colormap" onchange="onColormapChange()">
          <option value="Greys">Greys</option>
          <option value="RdBu">RdBu</option>
          <option value="BWR">BWR</option>
          <option value="Cividis">Cividis</option>
          <option value="Jet">Jet</option>
        </select>
        <label><input type="checkbox" id="cmReverse" onchange="onColormapChange()">reverse</label>
      </div>
      <div id="plot"></div>
    </div>
    <aside id="pipelinePanel">
      <div class="pipeline-header">
        <span>Pipeline</span>
        <div class="pipeline-actions">
          <button type="button" id="pipelineRunButton">▶ Run</button>
          <div class="pipeline-add">
            <button type="button" id="pipelineAddButton">+ Add Step ▾</button>
            <div class="pipeline-add-menu" id="pipelineAddMenu">
              <button type="button" data-step="bandpass">Bandpass</button>
              <button type="button" data-step="denoise">Denoise</button>
            </div>
          </div>
        </div>
      </div>
      <div id="pipelineCards"></div>
      <div id="pipelineInspector" class="pipeline-inspector hidden">
        <h3 id="pipelineInspectorTitle">Inspector</h3>
        <form id="pipelineInspectorForm">
          <div id="pipelineInspectorFields"></div>
          <div class="pipeline-inspector-actions">
            <button type="button" id="pipelineInspectorClose">Close</button>
            <button type="submit" id="pipelineInspectorSave">Save</button>
          </div>
        </form>
      </div>
    </aside>
  </div>
  <dialog id="denoiseSettingsDialog">
    <form method="dialog">
      <label>mask_ratio:<input type="number" id="dlg_mask_ratio" required step="0.1" min="0" max="1"></label>
      <label>noise_std:<input type="number" id="dlg_noise_std" required step="0.1"></label>
      <label>chunk_h:<input type="number" id="dlg_chunk_h" required step="1"></label>
      <label>overlap:<input type="number" id="dlg_overlap" required step="1"></label>
      <label>mask_noise_mode:
        <select id="dlg_mask_noise_mode" required>
          <option value="replace">replace</option>
          <option value="add">add</option>
        </select>
      </label>
      <div style="margin-top:1em;text-align:right;">
        <button type="button" onclick="saveDenoiseSettings()">保存</button>
        <button type="button" onclick="closeDenoiseSettings()">キャンセル</button>
      </div>
    </form>
  </dialog>
  <dialog id="bpfSettingsDialog">
    <form method="dialog">
      <label>low_hz:<input type="number" id="dlg_low_hz" required step="0.1"></label>
      <label>high_hz:<input type="number" id="dlg_high_hz" required step="0.1"></label>
      <label>dt:<input type="number" id="dlg_dt" required step="0.0001"></label>
      <label>taper:<input type="number" id="dlg_taper" required step="0.1"></label>
      <div style="margin-top:1em;text-align:right;">
        <button type="button" onclick="saveBpfSettings()">保存</button>
        <button type="button" onclick="closeBpfSettings()">キャンセル</button>
      </div>
    </form>
  </dialog>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script src="/static/pako.min.js"></script>
  <script src="/static/msgpack.min.js"></script>
  <script src="/static/api.js"></script>
  <script src="/static/pipeline_ui.js"></script>
  <script>
    var key1Values = [];
    var currentFileId = '';
    var currentKey1Byte = 189;
    var currentKey2Byte = 193;
    var savedXRange = null;
    var savedYRange = null;
    var latestSeismicData = null;
    var rawSeismicData = null;
    var latestTapData = {};
    var latestPipelineKey = null;
    var latestWindowRender = null;
    var windowFetchToken = 0;
    var windowFetchAbort = null;
    const defaultDt = 0.002;
    const PREFETCH_WIDTH = 3;
    const FALLBACK_MAX = 8;
    const HARD_LIMIT_BYTES = 512 * 1024 * 1024;
    const WINDOW_FETCH_DEBOUNCE_MS = 120;
    const WINDOW_MAX_POINTS = 1_200_000;
    const WIGGLE_DENSITY_THRESHOLD = 0.10;
    const WIGGLE_MAX_POINTS = 2_500_000;

    const cache = new Map(); // key -> { f32: Float32Array }
    const inflight = new Map();
    const CACHE_LIMIT = 12;
    function cacheKey(val, mode) { return `${val}|${mode}`; }
    var sectionShape = null;
    var renderedStart = null;
    var renderedEnd = null;
    var picks = [];
    var predictedPicks = [];
    const fbPredCache = new Map(); // key: "key1|layer|pipelineKey"
    var latestFbProbTraces = null;
    var currentFbKey = null;
    var fbPredReqId = 0;
    var downsampleFactor = 1;
    var isPickMode = false;
    var linePickStart = null;
    var deleteRangeStart = null;

    // Short suppression window for post-pick re-fetches
    let suppressUntil = 0;
    function suppressWindowFetch(ms = 150) {
      suppressUntil = performance.now() + ms;
    }

    let suppressRelayout = false;       // ignore relayouts we cause internally
    let forceFullExtentOnce = false;    // next window calc uses full extent with no padding

    // 追加：現在のFB計算に紐づくレイヤ/パイプラインキー
    let currentFbLayer = 'raw';
    let currentFbPipelineKey = null;

    // 統一キー関数（FB予測キャッシュ用）
    function fbCacheKey(k1, layer, pKey) {
      return `${k1}|${layer}|${pKey ?? 'raw'}`;
    }

    let lastPlotlyClickAt = 0;

    // Commit a pick at axis coords (x: trace index space, y: time in seconds)
    async function commitPickAt(axisX, axisY, mods = {}) {
      if (!isPickMode) return;

      const dt = defaultDt * downsampleFactor;
      const trace = Math.round(axisX);
      const time = Math.round(axisY / dt) * dt;
      const shift = !!mods.shift;
      const ctrl = !!mods.ctrl;
      const alt = !!mods.alt;
      void alt; // reserved for future use

      if (ctrl) {
        if (deleteRangeStart === null) {
          deleteRangeStart = trace;
          linePickStart = null;
          return;
        }
        const x0 = deleteRangeStart;
        deleteRangeStart = null;
        linePickStart = null;
        const x1 = trace;
        const start = Math.min(x0, x1);
        const end = Math.max(x0, x1);
        const toDelete = picks.filter((p) => {
          const t = Math.round(p.trace);
          return t >= start && t <= end;
        });
        const promises = toDelete.map((p) => deletePick(Math.round(p.trace)));
        picks = picks.filter((p) => {
          const t = Math.round(p.trace);
          return t < start || t > end;
        });
        await Promise.all(promises);
        suppressWindowFetch();
        renderLatestView();
        return;
      }

      if (shift) {
        if (!linePickStart) {
          linePickStart = { trace, time };
          deleteRangeStart = null;
          return;
        }

        const { trace: x0, time: y0 } = linePickStart;
        linePickStart = { trace, time };
        deleteRangeStart = null;
        const x1 = trace;
        const y1 = time;
        const xStart = Math.round(Math.min(x0, x1));
        const xEnd = Math.round(Math.max(x0, x1));
        const slope = x1 === x0 ? 0 : (y1 - y0) / (x1 - x0);
        const promises = [];
        for (let x = xStart; x <= xEnd; x++) {
          const y = x1 === x0 ? y1 : y0 + slope * (x - x0);
          const snapped = Math.round(y / dt) * dt;
          const idx = pickOnTrace(x);
          if (idx >= 0) {
            promises.push(deletePick(x));
            picks.splice(idx, 1);
          }
          picks.push({ trace: x, time: snapped });
          promises.push(postPick(x, snapped));
        }
        await Promise.all(promises);
        suppressWindowFetch();
        renderLatestView();
        return;
      }

      linePickStart = null;
      deleteRangeStart = null;
      const idx = pickOnTrace(trace);
      const promises = [];
      if (idx >= 0) {
        promises.push(deletePick(trace));
        picks.splice(idx, 1);
      }
      picks.push({ trace, time });
      promises.push(postPick(trace, time));
      await Promise.all(promises);
      suppressWindowFetch();
      renderLatestView();
    }

    const COLORMAPS = {
      Greys: 'Greys',
      RdBu: 'RdBu',
      BWR: [[0, 'blue'], [0.5, 'white'], [1, 'red']],
      Cividis: 'Cividis',
      Jet: 'Jet',
    };

    // Click handler that is always attached; pick mode gating is done here
    function onPlotlyClick(ev) {
      if (!isPickMode) return;
      lastPlotlyClickAt = performance.now();
      if (!ev?.points?.length) return;
      const p = ev.points[0];
      commitPickAt(p.x, p.y, {
        shift: !!ev.event?.shiftKey,
        ctrl: !!ev.event?.ctrlKey,
        alt: !!ev.event?.altKey,
      }).catch((err) => console.warn('Pick commit failed', err));
    }

    // Central place to (re)bind plot handlers
    function bindPlotHandlers(plotDiv) {
      if (!plotDiv || typeof plotDiv.removeAllListeners !== 'function') return;

      plotDiv.removeAllListeners('plotly_click');
      plotDiv.removeAllListeners('plotly_relayout');

      plotDiv.on('plotly_click', onPlotlyClick);
      plotDiv.on('plotly_relayout', handleRelayout);
    }

    function bindNativePickFallback(plotDiv) {
      if (!plotDiv) return;

      if (plotDiv.__nativePickDown) {
        plotDiv.removeEventListener('pointerdown', plotDiv.__nativePickDown, true);
      }
      if (plotDiv.__nativePickUp) {
        plotDiv.removeEventListener('pointerup', plotDiv.__nativePickUp, true);
      }

      let downInfo = null;

      function onDown(e) {
        if (!isPickMode || (e.button ?? 0) !== 0) return;
        downInfo = { x: e.clientX, y: e.clientY, t: performance.now() };
      }

      function onUp(e) {
        if (!isPickMode || (e.button ?? 0) !== 0) return;
        const d = downInfo;
        downInfo = null;
        if (!d) return;

        if (performance.now() - lastPlotlyClickAt < 60) return;

        if (Math.abs(e.clientX - d.x) > 6 || Math.abs(e.clientY - d.y) > 6) return;

        const plotDivLocal = plotDiv;
        if (!plotDivLocal || !plotDivLocal._fullLayout) return;

        const rect = plotDivLocal.getBoundingClientRect();
        const xpx = e.clientX - rect.left;
        const ypx = e.clientY - rect.top;
        const xa = plotDivLocal._fullLayout?.xaxis;
        const ya = plotDivLocal._fullLayout?.yaxis;
        if (!xa?.p2d || !ya?.p2d) return;

        const axisX = xa.p2d(xpx);
        const axisY = ya.p2d(ypx);
        if (!Number.isFinite(axisX) || !Number.isFinite(axisY)) return;

        commitPickAt(axisX, axisY, {
          shift: !!e.shiftKey,
          ctrl: !!e.ctrlKey,
          alt: !!e.altKey,
        }).catch((err) => console.warn('Fallback pick failed', err));
      }

      plotDiv.__nativePickDown = onDown;
      plotDiv.__nativePickUp = onUp;

      plotDiv.addEventListener('pointerdown', onDown, true);
      plotDiv.addEventListener('pointerup', onUp, true);
    }

    (function () {
      const saved = localStorage.getItem('denoise_params');
      if (saved) {
        try {
          const p = JSON.parse(saved);
          if (p.mask_ratio !== undefined) document.getElementById('mask_ratio').value = p.mask_ratio;
          if (p.noise_std !== undefined) document.getElementById('noise_std').value = p.noise_std;
          if (p.chunk_h !== undefined) document.getElementById('chunk_h').value = p.chunk_h;
          if (p.overlap !== undefined) document.getElementById('overlap').value = p.overlap;
          if (p.mask_noise_mode !== undefined) document.getElementById('mask_noise_mode').value = p.mask_noise_mode;
        } catch (e) { }
      }
    })();

    (function () {
      const saved = localStorage.getItem('bpf_params');
      if (saved) {
        try {
          const p = JSON.parse(saved);
          if (p.low_hz !== undefined) document.getElementById('low_hz').value = p.low_hz;
          if (p.high_hz !== undefined) document.getElementById('high_hz').value = p.high_hz;
          if (p.dt !== undefined) document.getElementById('dt').value = p.dt;
          if (p.taper !== undefined) document.getElementById('taper').value = p.taper;
        } catch (e) { }
      }
    })();

    (function () {
      const saved = localStorage.getItem('gain');
      const el = document.getElementById('gain');
      const disp = document.getElementById('gain_display');
      if (el && disp) {
        const val = saved !== null ? parseFloat(saved) : parseFloat(el.value);
        el.value = val; disp.textContent = `${val}×`;
      }
    })();

    (function () {
      const sel = document.getElementById('colormap');
      const chk = document.getElementById('cmReverse');
      if (sel) {
        const saved = localStorage.getItem('colormap');
        if (saved) sel.value = saved;
      }
      if (chk) {
        const savedRev = localStorage.getItem('cmReverse');
        if (savedRev !== null) chk.checked = savedRev === 'true';
      }
    })();

    (function restoreFbUi() {
      const sig = localStorage.getItem('sigma_ms_max');
      if (sig !== null) {
        const s = document.getElementById('sigma_ms_max');
        if (s) s.value = parseFloat(sig);
      }
      const pm = localStorage.getItem('pick_method');
      if (pm) {
        const sel = document.getElementById('pick_method');
        if (sel) sel.value = pm;
      }
      const sh = localStorage.getItem('showFbPred');
      if (sh !== null) {
        const c = document.getElementById('showFbPred');
        if (c) c.checked = (sh === 'true');
      }
    })();

    function getDenoiseParams() {
      return {
        mask_ratio: parseFloat(document.getElementById('mask_ratio').value),
        noise_std: parseFloat(document.getElementById('noise_std').value),
        chunk_h: parseInt(document.getElementById('chunk_h').value),
        overlap: parseInt(document.getElementById('overlap').value),
        mask_noise_mode: document.getElementById('mask_noise_mode').value,
      };
    }

    function getBpfParams() {
      return {
        low_hz: parseFloat(document.getElementById('low_hz').value),
        high_hz: parseFloat(document.getElementById('high_hz').value),
        dt: parseFloat(document.getElementById('dt').value),
        taper: parseFloat(document.getElementById('taper').value),
      };
    }

    // ★★★ FB確率取得：レイヤ/パイプライン対応（既存のジョブAPIを使用）
    async function fetchFbProb(key1Val, { layer = 'raw', pipelineKey = null } = {}) {
      const body = {
        file_id: currentFileId,
        key1_idx: key1Val,
        key1_byte: currentKey1Byte,
        key2_byte: currentKey2Byte,
        tile_h: 128,
        tile_w: 6016,
        overlap: 32,
        amp: true,
      };
      // パイプラインの特定レイヤで推論したい場合
      if (layer && layer !== 'raw' && pipelineKey) {
        body.pipeline_key = pipelineKey;
        body.tap_label = layer;
      }
      const res = await fetch('/fbpick_section_bin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        let message = `fbpick job failed (${res.status})`;
        try {
          const text = await res.text();
          if (text) {
            try {
              const parsed = JSON.parse(text);
              if (parsed && typeof parsed.detail === 'string') {
                message = parsed.detail;
              } else {
                message = text;
              }
            } catch (parseErr) {
              message = text;
            }
          }
        } catch (readErr) {
          // ignore body read errors
        }
        throw new Error(message);
      }
      const { job_id } = await res.json();

      // ポーリング
      while (true) {
        const st = await fetch(`/fbpick_job_status?job_id=${job_id}`);
        const js = await st.json();
        if (js.status === 'done') break;
        if (js.status === 'error') throw new Error(js.message || 'fbpick failed');
        await new Promise(r => setTimeout(r, 1000));
      }

      // 取得 & 復号
      const binRes = await fetch(`/get_fbpick_section_bin?job_id=${job_id}`);
      if (!binRes.ok) throw new Error('fbpick result fetch failed');
      const bin = new Uint8Array(await binRes.arrayBuffer());
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      const f32 = Float32Array.from(int8, v => v / obj.scale);
      return { f32, shape: obj.shape };
    }

    // prob2d: Array(H) of Float32Array(W); each row sums to ~1
    function picksFromProb(prob2d, dt, sigmaMaxMs = 20, method = 'argmax') {
      const H = prob2d.length;
      const W = prob2d[0].length;
      const picks = new Array(H).fill(-1);
      const dt_ms = dt * 1000;
      const eps = 1e-12;

      const t = new Float32Array(W);
      for (let i = 0; i < W; i++) t[i] = i;

      for (let h = 0; h < H; h++) {
        const p = prob2d[h];
        let s = 0.0;
        for (let i = 0; i < W; i++) s += p[i];
        if (!(s > eps) || !isFinite(s)) continue;
        const invs = 1.0 / s;
        let mu = 0.0;
        for (let i = 0; i < W; i++) mu += p[i] * t[i];
        mu *= invs;
        let v = 0.0;
        for (let i = 0; i < W; i++) {
          const d = t[i] - mu;
          v += p[i] * d * d;
        }
        v *= invs;
        const sigma_ms = Math.sqrt(Math.max(v, 0)) * dt_ms;
        if (sigma_ms > sigmaMaxMs) continue;
        if (method === 'expectation') {
          picks[h] = Math.round(mu);
        } else {
          let imax = 0, vmax = -Infinity;
          for (let i = 0; i < W; i++) if (p[i] > vmax) { vmax = p[i]; imax = i; }
          picks[h] = imax;
        }
      }
      return picks;
    }

    function computePicks(prob2d) {
      const sigmaMax = Number(document.getElementById('sigma_ms_max').value) || 20;
      const method = document.getElementById('pick_method').value;
      const dt = (window.defaultDt ?? defaultDt);
      const idxs = picksFromProb(prob2d, dt, sigmaMax, method);
      const out = [];
      for (let h = 0; h < idxs.length; h++) {
        const idx = idxs[h];
        if (idx >= 0) out.push({ trace: h, time: idx * dt });
      }
      return out;
    }

    function recomputeFbPicks() {
      if (!latestFbProbTraces) return;

      const idx0 = parseInt(document.getElementById('key1_idx_slider').value, 10);
      const keyAtNow = key1Values[idx0];
      const layerNow = (document.getElementById('layerSelect')?.value) || 'raw';
      const pKeyNow = window.latestPipelineKey || null;

      // 現在のセクション＆レイヤ＆パイプラインキーに紐づく確率以外は再計算しない
      if (currentFbKey !== keyAtNow ||
        currentFbLayer !== layerNow ||
        currentFbPipelineKey !== pKeyNow) {
        return;
      }

      const picksNow = computePicks(latestFbProbTraces);
      predictedPicks = picksNow;
      fbPredCache.set(fbCacheKey(currentFbKey, currentFbLayer, currentFbPipelineKey), picksNow);

      renderLatestView();
    }

    function onSigmaChange() {
      localStorage.setItem('sigma_ms_max', document.getElementById('sigma_ms_max').value);
      recomputeFbPicks();
    }
    function onPickMethodChange() {
      localStorage.setItem('pick_method', document.getElementById('pick_method').value);
      recomputeFbPicks();
    }

    async function predictFromFb() {
      // Snapshot
      const idx0 = parseInt(document.getElementById('key1_idx_slider').value, 10);
      const keyAtStart = key1Values[idx0];
      const layerAtStart = (document.getElementById('layerSelect')?.value) || 'raw';
      const pipelineKeyAtStart = window.latestPipelineKey || null;

      // Request token
      const reqToken = ++fbPredReqId;

      const btn = document.getElementById('predictFbBtn');
      if (btn) btn.disabled = true;

      try {
        // Ensure probs
        let tracesLocal = latestFbProbTraces;
        if (!tracesLocal ||
          currentFbKey !== keyAtStart ||
          currentFbLayer !== layerAtStart ||
          currentFbPipelineKey !== pipelineKeyAtStart) {

          const { f32, shape } = await fetchFbProb(keyAtStart, { layer: layerAtStart, pipelineKey: pipelineKeyAtStart });
          const [nTraces, nSamples] = shape;
          const traces = new Array(nTraces);
          for (let i = 0; i < nTraces; i++) {
            traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
          }
          tracesLocal = traces;
        }

        // Compute picks locally
        const picks = computePicks(tracesLocal);

        // Guard against stale
        const idxNow = parseInt(document.getElementById('key1_idx_slider').value, 10);
        const keyNow = key1Values[idxNow];
        const layerNow = (document.getElementById('layerSelect')?.value) || 'raw';
        const pipelineKeyNow = window.latestPipelineKey || null;
        if (reqToken !== fbPredReqId ||
          keyNow !== keyAtStart ||
          layerNow !== layerAtStart ||
          pipelineKeyNow !== pipelineKeyAtStart) {
          return;
        }

        // Commit
        predictedPicks = picks;
        latestFbProbTraces = tracesLocal;
        currentFbKey = keyAtStart;
        currentFbLayer = layerAtStart;
        currentFbPipelineKey = pipelineKeyAtStart;
        fbPredCache.set(fbCacheKey(keyAtStart, layerAtStart, pipelineKeyAtStart), picks);

        // Replot
        renderLatestView();
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    function onGainChange() {
      const val = document.getElementById('gain').value;
      document.getElementById('gain_display').textContent = `${parseFloat(val)}×`;
      localStorage.setItem('gain', val);
      renderLatestView();
    }

    function onColormapChange() {
      const sel = document.getElementById('colormap');
      const chk = document.getElementById('cmReverse');
      if (sel) localStorage.setItem('colormap', sel.value);
      if (chk) localStorage.setItem('cmReverse', chk.checked);
      renderLatestView();
    }

    function openDenoiseSettings() {
      document.getElementById('dlg_mask_ratio').value = document.getElementById('mask_ratio').value;
      document.getElementById('dlg_noise_std').value = document.getElementById('noise_std').value;
      document.getElementById('dlg_chunk_h').value = document.getElementById('chunk_h').value;
      document.getElementById('dlg_overlap').value = document.getElementById('overlap').value;
      document.getElementById('dlg_mask_noise_mode').value = document.getElementById('mask_noise_mode').value;
      const dlg = document.getElementById('denoiseSettingsDialog');
      if (dlg.showModal) dlg.showModal(); else dlg.style.display = 'block';
    }
    function closeDenoiseSettings() {
      const dlg = document.getElementById('denoiseSettingsDialog');
      if (dlg.close) dlg.close(); else dlg.style.display = 'none';
    }
    function saveDenoiseSettings() {
      document.getElementById('mask_ratio').value = document.getElementById('dlg_mask_ratio').value;
      document.getElementById('noise_std').value = document.getElementById('dlg_noise_std').value;
      document.getElementById('chunk_h').value = document.getElementById('dlg_chunk_h').value;
      document.getElementById('overlap').value = document.getElementById('dlg_overlap').value;
      document.getElementById('mask_noise_mode').value = document.getElementById('dlg_mask_noise_mode').value;
      localStorage.setItem('denoise_params', JSON.stringify(getDenoiseParams()));
      closeDenoiseSettings();
      if (typeof fetchAndPlot === 'function') { try { fetchAndPlot(); } catch (e) { } }
    }

    function openBpfSettings() {
      document.getElementById('dlg_low_hz').value = document.getElementById('low_hz').value;
      document.getElementById('dlg_high_hz').value = document.getElementById('high_hz').value;
      document.getElementById('dlg_dt').value = document.getElementById('dt').value;
      document.getElementById('dlg_taper').value = document.getElementById('taper').value;
      const dlg = document.getElementById('bpfSettingsDialog');
      if (dlg.showModal) dlg.showModal(); else dlg.style.display = 'block';
    }
    function closeBpfSettings() {
      const dlg = document.getElementById('bpfSettingsDialog');
      if (dlg.close) dlg.close(); else dlg.style.display = 'none';
    }
    function saveBpfSettings() {
      document.getElementById('low_hz').value = document.getElementById('dlg_low_hz').value;
      document.getElementById('high_hz').value = document.getElementById('dlg_high_hz').value;
      document.getElementById('dt').value = document.getElementById('dlg_dt').value;
      document.getElementById('taper').value = document.getElementById('dlg_taper').value;
      localStorage.setItem('bpf_params', JSON.stringify(getBpfParams()));
      closeBpfSettings();
      if (typeof fetchAndPlot === 'function') { try { fetchAndPlot(); } catch (e) { } }
    }

    async function pollDenoiseJob(jobId) {
      const bar = document.getElementById('denoiseProgress');
      const txt = document.getElementById('denoiseProgressText');
      bar.style.display = 'inline-block';
      bar.value = 0;
      txt.textContent = '0%';
      const timer = setInterval(async () => {
        const res = await fetch(`/denoise_job_status?job_id=${jobId}`);
        if (!res.ok) return;
        const data = await res.json();
        bar.value = data.progress;
        txt.textContent = `${Math.round(data.progress * 100)}%`;
        if (data.status === 'done') {
          clearInterval(timer);
          cache.clear();
          await fetchAndPlot();
          setTimeout(() => { bar.style.display = 'none'; txt.textContent = ''; }, 1000);
        } else if (data.status === 'error') {
          clearInterval(timer);
          txt.textContent = `error`;
        }
      }, 1000);
    }

    async function pollBpfJob(jobId) {
      const bar = document.getElementById('denoiseProgress');
      const txt = document.getElementById('denoiseProgressText');
      bar.style.display = 'inline-block';
      bar.value = 0;
      txt.textContent = 'BPF 0%';
      const timer = setInterval(async () => {
        const res = await fetch(`/bandpass_job_status?job_id=${jobId}`);
        if (!res.ok) return;
        const data = await res.json();
        bar.value = data.progress;
        txt.textContent = `BPF ${Math.round(data.progress * 100)}%`;
        if (data.status === 'done') {
          clearInterval(timer);
          cache.clear();
          await fetchAndPlot();
          setTimeout(() => { bar.style.display = 'none'; txt.textContent = ''; }, 1000);
        } else if (data.status === 'error') {
          clearInterval(timer);
          txt.textContent = 'BPF error';
        }
      }, 1000);
    }

    async function handleDenoise() {
      const scope = document.getElementById('denoiseScope').value;
      const params = getDenoiseParams();
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      if (scope === 'display') {
        const body = {
          file_id: currentFileId, key1_idx: key1Val,
          key1_byte: currentKey1Byte, key2_byte: currentKey2Byte, ...params,
        };
        const res = await fetch('/denoise_section_bin', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body),
        });
        if (!res.ok) { alert('denoise failed'); return; }
        const bin = new Uint8Array(await res.arrayBuffer());
        const obj = msgpack.decode(bin);
        const int8 = new Int8Array(obj.data.buffer);
        const f32 = Float32Array.from(int8, v => v / obj.scale);
        putCacheF32(cacheKey(key1Val, 'den'), f32);
        sectionShape = obj.shape;
        await fetchAndPlot();
      } else {
        const body = {
          file_id: currentFileId,
          scope: scope === 'all_key1' ? 'all_key1' : 'by_header',
          key1_byte: currentKey1Byte, key2_byte: currentKey2Byte, ...params,
        };
        if (scope !== 'all_key1') {
          body.key1_idx = key1Val;
          body.group_header_byte = scope === 'common_shot' ? currentKey1Byte : currentKey2Byte;
        }
        const res = await fetch('/denoise_apply', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body),
        });
        if (!res.ok) { alert('denoise apply failed'); return; }
        const data = await res.json();
        pollDenoiseJob(data.job_id);
      }
    }

    async function handleBandpass() {
      const params = getBpfParams();
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      const body = {
        file_id: currentFileId, key1_idx: key1Val,
        key1_byte: currentKey1Byte, key2_byte: currentKey2Byte, ...params,
      };
      const res = await fetch('/bandpass_section_bin', {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body),
      });
      if (!res.ok) { alert('bandpass failed'); return; }
      const bin = new Uint8Array(await res.arrayBuffer());
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      const f32 = Float32Array.from(int8, v => v / obj.scale);
      putCacheF32(cacheKey(key1Val, 'filt'), f32);
      sectionShape = obj.shape;
      await fetchAndPlot();
    }

    async function applyBandpassBatch() {
      const scope = document.getElementById('denoiseScope').value;
      const params = getBpfParams();
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      if (scope === 'display') {
        await handleBandpass();
      } else {
        const body = {
          file_id: currentFileId,
          scope: scope === 'all_key1' ? 'all_key1' : 'by_header',
          key1_byte: currentKey1Byte, key2_byte: currentKey2Byte, ...params,
        };
        if (scope !== 'all_key1') {
          body.key1_idx = key1Val;
          body.group_header_byte = scope === 'common_shot' ? currentKey1Byte : currentKey2Byte;
        }
        const res = await fetch('/bandpass_apply', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body),
        });
        if (!res.ok) { alert('bandpass apply failed'); return; }
        const data = await res.json();
        pollBpfJob(data.job_id);
      }
    }

    function togglePickMode() {
      isPickMode = !isPickMode;
      const btn = document.getElementById('pickModeBtn');
      btn.textContent = isPickMode ? 'Pick Mode: ON' : 'Pick Mode: OFF';
      btn.classList.toggle('active', isPickMode);
      // Toggle CSS class so shapes ignore clicks while picking
      document.body.classList.toggle('pick-mode', isPickMode);
      linePickStart = null;
      deleteRangeStart = null;
      renderLatestView();
    }

    function getSeismicForProcessing() {
      const sel = document.getElementById('layerSelect');
      const layer = sel?.value || 'raw';
      return layer === 'raw' ? rawSeismicData : (latestTapData[layer] || rawSeismicData);
    }

    function putCacheF32(key, f32) {
      if (cache.size >= CACHE_LIMIT) {
        const oldestKey = cache.keys().next().value;
        const old = cache.get(oldestKey);
        if (old) old.f32 = null;
        cache.delete(oldestKey);
      }
      cache.set(key, { f32 });

      const canCheckMemory = performance.memory && performance.memory.usedJSHeapSize > 0;
      const used = canCheckMemory ? performance.memory.usedJSHeapSize : 0;

      console.log('--- putCache called ---');
      console.log('Added key:', cache.keys());
      console.log('Cache size:', cache.size);
      if (canCheckMemory) {
        const total = performance.memory.totalJSHeapSize;
        console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB`);
      } else {
        console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB (fallback, no total)`);
      }

      if (used > HARD_LIMIT_BYTES) {
        console.warn(`⚠ Memory limit exceeded! (${(used / 1024 / 1024).toFixed(1)} MB > 512 MB)`);
        let removed = 0;
        while (cache.size > 1) {
          const removedKey = cache.keys().next().value;
          const entry = cache.get(removedKey);
          if (entry) entry.f32 = null;
          cache.delete(removedKey);
          removed++;
        }
        console.warn(`Evicted ${removed} items due to hard heap limit.`);
        console.log('Remaining keys:', Array.from(cache.keys()));
      }
      console.log('------------------------');
    }

    function getCacheF32(key) {
      if (!cache.has(key)) return null;
      const entry = cache.get(key);
      cache.delete(key); cache.set(key, entry); // refresh LRU
      return entry;
    }

    function debounce(fn, delay) {
      let timer = null;
      return function debounced(...args) {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
          timer = null;
          fn.apply(this, args);
        }, delay);
      };
    }

    function roundUpPowerOfTwo(value) {
      let v = Math.max(1, Math.floor(value));
      v -= 1;
      v |= v >> 1;
      v |= v >> 2;
      v |= v >> 4;
      v |= v >> 8;
      v |= v >> 16;
      return v + 1;
    }

    function computeStepsForWindow({
      tracesVisible,
      samplesVisible,
      widthPx,
      heightPx,
      oversampleX = 1.2,
      oversampleY = 1.2,
      maxPoints = WINDOW_MAX_POINTS,
    }) {
      const ratio = window.devicePixelRatio || 1;
      const effW = Math.max(1, Math.round(widthPx * ratio));
      const effH = Math.max(1, Math.round(heightPx * ratio));
      let stepX = Math.max(1, Math.ceil(tracesVisible / (effW * oversampleX)));
      let stepY = Math.max(1, Math.ceil(samplesVisible / (effH * oversampleY)));

      const tracesOut = () => Math.ceil(tracesVisible / stepX);
      const samplesOut = () => Math.ceil(samplesVisible / stepY);

      let guard = 0;
      while (tracesOut() * samplesOut() > maxPoints && guard < 512) {
        if (tracesOut() / effW > samplesOut() / effH) {
          stepX += 1;
        } else {
          stepY += 1;
        }
        guard += 1;
      }

      stepX = roundUpPowerOfTwo(stepX);
      stepY = roundUpPowerOfTwo(stepY);

      guard = 0;
      while (Math.ceil(tracesVisible / stepX) * Math.ceil(samplesVisible / stepY) > maxPoints && guard < 512) {
        if (tracesVisible / stepX > samplesVisible / stepY) {
          stepX = roundUpPowerOfTwo(stepX + 1);
        } else {
          stepY = roundUpPowerOfTwo(stepY + 1);
        }
        guard += 1;
      }

      return { step_x: stepX, step_y: stepY };
    }

    function wantWiggleForWindow({ tracesVisible, samplesVisible, widthPx }) {
      const density = tracesVisible / Math.max(1, widthPx);
      if (density >= WIGGLE_DENSITY_THRESHOLD) return false;
      if ((tracesVisible * samplesVisible) > WIGGLE_MAX_POINTS) return false;
      return true;
    }

    function currentVisibleWindow() {
      if (!sectionShape) return null;
      const [totalTraces, totalSamples] = sectionShape;

      // X range
      let x0, x1;
      if (forceFullExtentOnce) {
        x0 = 0; x1 = totalTraces - 1;
      } else if (savedXRange && savedXRange.length === 2) {
        const minX = Math.min(savedXRange[0], savedXRange[1]);
        const maxX = Math.max(savedXRange[0], savedXRange[1]);
        x0 = Math.floor(minX);
        x1 = Math.ceil(maxX);
      } else if (typeof renderedStart === 'number' && typeof renderedEnd === 'number') {
        x0 = renderedStart;
        x1 = renderedEnd;
      } else {
        x0 = 0;
        x1 = totalTraces - 1;
      }

      x0 = Math.max(0, Math.floor(x0));
      x1 = Math.min(totalTraces - 1, Math.ceil(x1));
      if (x1 < x0) [x0, x1] = [x1, x0];

      const spanX = Math.max(1, x1 - x0 + 1);
      const padX = (!forceFullExtentOnce && !!savedXRange)
        ? Math.max(1, Math.floor(spanX * 0.1))
        : 0;
      x0 = Math.max(0, x0 - padX);
      x1 = Math.min(totalTraces - 1, x1 + padX);

      // Y range
      const dtBase = window.defaultDt ?? defaultDt;
      let yMinSec, yMaxSec;
      if (!forceFullExtentOnce && savedYRange && savedYRange.length === 2) {
        yMinSec = Math.min(savedYRange[0], savedYRange[1]);
        yMaxSec = Math.max(savedYRange[0], savedYRange[1]);
      } else {
        yMinSec = 0;
        yMaxSec = (totalSamples - 1) * dtBase;
      }

      let y0 = Math.floor(yMinSec / dtBase);
      let y1 = Math.ceil(yMaxSec / dtBase);
      y0 = Math.max(0, y0);
      y1 = Math.min(totalSamples - 1, y1);
      if (y1 < y0) [y0, y1] = [y1, y0];

      const spanY = Math.max(1, y1 - y0 + 1);
      const padY = (!forceFullExtentOnce && !!savedYRange)
        ? Math.max(1, Math.floor(spanY * 0.1))
        : 0;
      y0 = Math.max(0, y0 - padY);
      y1 = Math.min(totalSamples - 1, y1 + padY);

      // one-shot full-extent is consumed here
      if (forceFullExtentOnce) forceFullExtentOnce = false;

      return {
        x0, x1, y0, y1,
        nTraces: x1 - x0 + 1,
        nSamples: y1 - y0 + 1,
      };
    }

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

    async function fetchKey1Values() {
      const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
      if (res.ok) {
        const data = await res.json();
        key1Values = data.values;
        setKey1SliderMax(key1Values.length - 1);
        document.getElementById('key1_idx_display').min = key1Values[0];
        document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
        document.getElementById('key1_idx_slider').value = 0;
        updateKey1Display();
      }
    }

    function prefetchAround(centerIdx, mode) {
      if (mode === 'denoised' || mode === 'fbprob') return;
      for (const ctrl of inflight.values()) ctrl.abort();
      inflight.clear();
      const start = Math.max(0, centerIdx - PREFETCH_WIDTH);
      const end = Math.min(key1Values.length - 1, centerIdx + PREFETCH_WIDTH);
      const scheduler = cb => { ('requestIdleCallback' in window) ? requestIdleCallback(cb) : setTimeout(cb, 0); };
      for (let i = start; i <= end; i++) {
        if (i === centerIdx) continue;
        const key1Val = key1Values[i];
        if (mode === 'auto') {
          if (cache.has(cacheKey(key1Val, 'den')) || cache.has(cacheKey(key1Val, 'filt')) || cache.has(cacheKey(key1Val, 'raw')) ||
            inflight.has(cacheKey(key1Val, 'den')) || inflight.has(cacheKey(key1Val, 'filt')) || inflight.has(cacheKey(key1Val, 'raw'))) continue;
        } else {
          const ck = cacheKey(key1Val, mode === 'denoised' ? 'den' : mode === 'filtered' ? 'filt' : 'raw');
          if (cache.has(ck) || inflight.has(ck)) continue;
        }
        const controller = new AbortController();
        const inflightKey = mode === 'raw' ? cacheKey(key1Val, 'raw') :
          mode === 'denoised' ? cacheKey(key1Val, 'den') :
            mode === 'filtered' ? cacheKey(key1Val, 'filt') :
              cacheKey(key1Val, 'den');
        inflight.set(inflightKey, controller);
        scheduler(async () => {
          try {
            const denoiseParams = getDenoiseParams();
            const bpfParams = getBpfParams();
            const urlDen = `/get_denoised_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&chunk_h=${denoiseParams.chunk_h}&overlap=${denoiseParams.overlap}&mask_ratio=${denoiseParams.mask_ratio}&noise_std=${denoiseParams.noise_std}&mask_noise_mode=${denoiseParams.mask_noise_mode}`;
            const urlFilt = `/get_bandpassed_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&low_hz=${bpfParams.low_hz}&high_hz=${bpfParams.high_hz}&dt=${bpfParams.dt}&taper=${bpfParams.taper}`;
            const urlRaw = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
            let res;
            let fetchedMode = 'raw';
            if (mode === 'raw') {
              res = await fetch(urlRaw, { signal: controller.signal });
              if (!res.ok) return;
            } else if (mode === 'denoised') {
              res = await fetch(urlDen, { signal: controller.signal });
              if (res.ok) fetchedMode = 'den';
              else { res = await fetch(urlRaw, { signal: controller.signal }); if (!res.ok) return; }
            } else if (mode === 'filtered') {
              res = await fetch(urlFilt, { signal: controller.signal });
              if (res.ok) fetchedMode = 'filt';
              else { res = await fetch(urlRaw, { signal: controller.signal }); if (!res.ok) return; }
            } else {
              res = await fetch(urlDen, { signal: controller.signal });
              if (res.ok) fetchedMode = 'den';
              else {
                res = await fetch(urlFilt, { signal: controller.signal });
                if (res.ok) fetchedMode = 'filt';
                else { res = await fetch(urlRaw, { signal: controller.signal }); if (!res.ok) return; }
              }
            }
            const bin = new Uint8Array(await res.arrayBuffer());
            const obj = msgpack.decode(bin);
            const int8 = new Int8Array(obj.data.buffer);
            const f32 = Float32Array.from(int8, v => v / obj.scale);
            putCacheF32(cacheKey(key1Val, fetchedMode), f32);
            if (!sectionShape) sectionShape = obj.shape;
          } catch (err) {
            if (err.name !== 'AbortError') console.warn('Prefetch failed', key1Val, err);
          } finally {
            inflight.delete(inflightKey);
          }
        });
      }
    }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchPicks();
        await fetchAndPlot();
      }
    }

    async function fetchPicks() {
      if (!currentFileId) return;
      const idx = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[idx];
      try {
        const res = await fetch(`/picks?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`);
        if (res.ok) {
          const data = await res.json();
          picks = (data.picks || []).map(p => ({ trace: p.trace, time: p.time }));
        }
      } catch (e) { console.error('Failed to fetch picks', e); }
    }

    async function postPick(trace, time) {
      const idx = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[idx];
      try {
        await fetch('/picks', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file_id: currentFileId, trace, time, key1_idx: key1Val, key1_byte: currentKey1Byte })
        });
      } catch (e) { console.error('Failed to post pick', e); }
    }

    async function deletePick(trace) {
      const idx = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[idx];
      try {
        await fetch(`/picks?file_id=${currentFileId}&trace=${trace}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`, { method: 'DELETE' });
      } catch (e) { console.error('Failed to delete pick', e); }
    }

    async function fetchAndPlot() {
      console.log('--- fetchAndPlot start ---');
      console.time('Total fetchAndPlot');

      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];

      // ★ FB予測キャッシュ取得：レイヤ＆パイプラインキーでキー統一
      const layerCur = (document.getElementById('layerSelect')?.value) || 'raw';
      const pKeyCur = window.latestPipelineKey || null;
      predictedPicks = fbPredCache.get(fbCacheKey(key1Val, layerCur, pKeyCur)) || [];

      await fetchPicks();

      console.time('Cache lookup');
      const hit = getCacheF32(cacheKey(key1Val, 'raw'));
      console.timeEnd('Cache lookup');

      let traces;
      let f32 = hit ? hit.f32 : null;

      if (f32) {
        console.time('Decode from cache');
        const [nTraces, nSamples] = sectionShape;
        traces = new Array(nTraces);
        for (let i = 0; i < nTraces; i++) {
          traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
        }
        console.timeEnd('Decode from cache');
        rawSeismicData = traces;
      } else {
        console.time('Fetch binary');
        const urlRaw = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
        const res = await fetch(urlRaw);
        if (!res.ok) {
          console.timeEnd('Fetch binary');
          alert('Failed to load section');
          return;
        }
        const bin = new Uint8Array(await res.arrayBuffer());
        console.timeEnd('Fetch binary');

        console.time('Decode & cache');
        const obj = msgpack.decode(bin);
        const int8 = new Int8Array(obj.data.buffer);
        f32 = Float32Array.from(int8, (v) => v / obj.scale);
        putCacheF32(cacheKey(key1Val, 'raw'), f32);
        sectionShape = obj.shape;
        const [nTraces, nSamples] = sectionShape;
        traces = new Array(nTraces);
        for (let i = 0; i < nTraces; i++) {
          traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
        }
        console.timeEnd('Decode & cache');
        rawSeismicData = traces;
      }

      latestWindowRender = null;
      windowFetchToken += 1;

      if (window.pipelineUI && typeof window.pipelineUI.prepareForNewSection === 'function') {
        window.pipelineUI.prepareForNewSection();
      } else {
        latestTapData = {};
        latestPipelineKey = null;
        const sel = document.getElementById('layerSelect');
        if (sel) {
          sel.innerHTML = '';
          sel.appendChild(new Option('raw', 'raw'));
          sel.value = 'raw';
        }
      }

      const totalTraces = rawSeismicData ? rawSeismicData.length : (sectionShape ? sectionShape[0] : 0);
      const [s, e] = totalTraces > 0
        ? (savedXRange ? visibleTraceIndices(savedXRange, totalTraces) : [0, totalTraces - 1])
        : [0, 0];
      drawSelectedLayer(s, e);

      // Pipeline execution: manual via ▶ Run button

      console.time('Prefetch');
      prefetchAround(index, 'raw');
      console.timeEnd('Prefetch');

      console.timeEnd('Total fetchAndPlot');
      console.log('--- fetchAndPlot end ---');
    }

    function shouldPreferWindowFirst() {
      const win = currentVisibleWindow();
      const plotDiv = document.getElementById('plot');
      if (!win || !plotDiv) return false;
      const { step_x, step_y } = computeStepsForWindow({
        tracesVisible: win.nTraces,
        samplesVisible: win.nSamples,
        widthPx: plotDiv.clientWidth || 1,
        heightPx: plotDiv.clientHeight || 1,
      });
      return (step_x > 1 || step_y > 1);
    }

    function drawSelectedLayer(start = null, end = null) {
      const sel = document.getElementById('layerSelect');
      const layer = sel ? sel.value : 'raw';
      latestSeismicData = (layer === 'raw') ? rawSeismicData : (latestTapData[layer] || null);

      if (shouldPreferWindowFirst()) {
        // 最初からウィンドウ版に任せる（フル描画をスキップ）
        latestSeismicData = null;
        renderLatestView();      // 既存：必要なら状態維持（スピナー等を出すならここ）
        fetchWindowAndPlot();    // 即時フェッチ
        return;
      }

      // 低負荷なら従来どおりフル描画
      const total = latestSeismicData ? latestSeismicData.length : (sectionShape ? sectionShape[0] : 0);
      const s = (typeof start === 'number') ? start : 0;
      const e = (typeof end === 'number') ? end : Math.max(0, total - 1);
      if (latestSeismicData) {
        plotSeismicData(latestSeismicData, defaultDt, s, e);
      } else {
        renderLatestView();
      }
      scheduleWindowFetch();
    }

    function renderWindowWiggle(windowData) {
      if (!windowData || (windowData.mode && windowData.mode !== 'wiggle')) return;

      const sel = document.getElementById('layerSelect');
      const currentLayer = sel ? sel.value : 'raw';
      if (windowData.requestedLayer !== currentLayer) return;

      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];
      if (windowData.key1 !== key1Val) return;

      if (windowData.pipelineKey && (window.latestPipelineKey || null) !== (windowData.pipelineKey || null)) {
        return;
      }

      if (windowData.effectiveLayer === 'fbprob') return;

      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;

      const { values, shape, x0, x1, y0, y1, stepX = 1, stepY = 1 } = windowData;
      const rows = Number(shape?.[0] ?? 0);
      const cols = Number(shape?.[1] ?? 0);
      if (!rows || !cols) return;
      if (values.length !== rows * cols) return;

      const dt = window.defaultDt ?? defaultDt;
      const time = new Float32Array(rows);
      for (let r = 0; r < rows; r++) time[r] = (y0 + r * stepY) * dt;

      const traces = [];
      const gain = parseFloat(document.getElementById('gain').value) || 1.0;
      const AMP_LIMIT = 3.0;

      for (let c = 0; c < cols; c++) {
        const baseX = new Float32Array(rows);
        const shiftedFullX = new Float32Array(rows);
        const shiftedPosX = new Float32Array(rows);
        const traceIndex = x0 + c * stepX;
        for (let r = 0; r < rows; r++) {
          const idxVal = r * cols + c;
          let val = values[idxVal] * gain;
          if (val > AMP_LIMIT) val = AMP_LIMIT;
          if (val < -AMP_LIMIT) val = -AMP_LIMIT;

          baseX[r] = traceIndex;
          shiftedFullX[r] = traceIndex + val;
          shiftedPosX[r] = traceIndex + (val < 0 ? 0 : val);
        }

        traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'x+y', showlegend: false });
        traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
        traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, hoverinfo: 'skip', showlegend: false });
      }

      downsampleFactor = 1;
      const endTrace = typeof x1 === 'number' ? x1 : x0 + cols - 1;
      renderedStart = x0;
      renderedEnd = endTrace;

      const totalTraces = sectionShape ? sectionShape[0] : endTrace - x0 + 1;
      const totalSamples = sectionShape ? sectionShape[1] : (typeof y1 === 'number' ? y1 - y0 + 1 : rows);
      const baseDt = dt;
      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          range: savedXRange ?? [x0, endTrace],
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [totalSamples * baseDt, 0],
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: isPickMode ? false : 'zoom',
      };

      const manualShapes = picks.map((p) => ({
        type: 'line',
        x0: p.trace - 0.4,
        x1: p.trace + 0.4,
        y0: p.time,
        y1: p.time,
        line: { color: 'red', width: 2 },
        layer: 'below',
      }));

      const showPred = document.getElementById('showFbPred')?.checked;
      const predShapes = (showPred ? predictedPicks : [])
        .filter((p) => p.trace >= x0 && p.trace <= endTrace)
        .map((p) => ({
          type: 'line',
          x0: p.trace - 0.4,
          x1: p.trace + 0.4,
          y0: p.time,
          y1: p.time,
          line: { color: '#1f77b4', width: 5, dash: 'dot' },
          layer: 'below',
        }));

      layout.shapes = [...manualShapes, ...predShapes];
      layout.dragmode = isPickMode ? false : 'zoom';

      Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: !isPickMode,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false },
      });
      if (typeof plotDiv.on === 'function') {
        plotDiv.removeAllListeners && plotDiv.removeAllListeners('plotly_afterplot');
        plotDiv.on('plotly_afterplot', () => {
          bindPlotHandlers(plotDiv);
          bindNativePickFallback(plotDiv);
        });
      }

      setTimeout(() => {
        suppressRelayout = true;
        Plotly.Plots.resize(plotDiv);
        suppressRelayout = false;
      }, 50);

      // Always (re)attach handlers in one place
      bindPlotHandlers(plotDiv);
      bindNativePickFallback(plotDiv);
    }

    function renderWindowHeatmap(windowData) {
      if (!windowData || (windowData.mode && windowData.mode !== 'heatmap')) return;
      const sel = document.getElementById('layerSelect');
      const currentLayer = sel ? sel.value : 'raw';
      if (windowData.requestedLayer !== currentLayer) return;

      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];
      if (windowData.key1 !== key1Val) return;

      if (windowData.pipelineKey && (window.latestPipelineKey || null) !== (windowData.pipelineKey || null)) {
        return;
      }

      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;

      const { values, shape, x0, x1, y0, y1, stepX, stepY, effectiveLayer } = windowData;
      const rows = Number(shape?.[0] ?? 0);
      const cols = Number(shape?.[1] ?? 0);
      if (!rows || !cols) return;
      if (values.length !== rows * cols) return;

      const gain = parseFloat(document.getElementById('gain').value) || 1.0;
      const AMP_LIMIT = 3.0;
      const fbMode = effectiveLayer === 'fbprob';
      const zData = new Array(rows);
      for (let r = 0; r < rows; r++) {
        const row = new Float32Array(cols);
        const offset = r * cols;
        for (let c = 0; c < cols; c++) {
          let val = values[offset + c];
          if (fbMode) {
            row[c] = val * 255;
          } else {
            val *= gain;
            if (val > AMP_LIMIT) val = AMP_LIMIT;
            else if (val < -AMP_LIMIT) val = -AMP_LIMIT;
            row[c] = val;
          }
        }
        zData[r] = row;
      }

      const xVals = new Float32Array(cols);
      for (let c = 0; c < cols; c++) xVals[c] = x0 + c * stepX;

      const baseDt = window.defaultDt ?? defaultDt;
      const yVals = new Float32Array(rows);
      for (let r = 0; r < rows; r++) yVals[r] = (y0 + r * stepY) * baseDt;

      downsampleFactor = stepY || 1;
      renderedStart = x0;
      renderedEnd = x1;

      const cmName = document.getElementById('colormap')?.value || 'Greys';
      const reverse = document.getElementById('cmReverse')?.checked || false;
      const cm = COLORMAPS[cmName] || 'Greys';
      const isDiv = cmName === 'RdBu' || cmName === 'BWR';
      const zMin = fbMode ? 0 : -AMP_LIMIT;
      const zMax = fbMode ? 255 : AMP_LIMIT;

      const traces = [{
        type: 'heatmap',
        x: xVals,
        y: yVals,
        z: zData,
        colorscale: cm,
        reversescale: reverse,
        zmin: zMin,
        zmax: zMax,
        ...(fbMode ? {} : (isDiv ? { zmid: 0 } : {})),
        showscale: false,
        hoverinfo: 'x+y',
        hovertemplate: '',
      }];

      const totalTraces = sectionShape ? sectionShape[0] : x1 - x0 + 1;
      const totalSamples = sectionShape ? sectionShape[1] : y1 - y0 + 1;
      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          range: savedXRange ?? [x0, x1],
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [totalSamples * baseDt, 0],
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: isPickMode ? false : 'zoom',
        ...(fbMode ? { title: 'First-break Probability' } : {}),
      };

      const manualShapes = picks.map((p) => ({
        type: 'line',
        x0: p.trace - 0.4,
        x1: p.trace + 0.4,
        y0: p.time,
        y1: p.time,
        line: { color: 'red', width: 2 },
      }));

      const showPred = document.getElementById('showFbPred')?.checked;
      const predShapes = (showPred ? predictedPicks : [])
        .filter((p) => p.trace >= x0 && p.trace <= x1)
        .map((p) => ({
          type: 'line',
          x0: p.trace - 0.4,
          x1: p.trace + 0.4,
          y0: p.time,
          y1: p.time,
          line: { color: '#1f77b4', width: 5, dash: 'dot' },
        }));

      layout.shapes = [...manualShapes, ...predShapes];
      layout.dragmode = isPickMode ? false : 'zoom';

      Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: !isPickMode,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false },
      });

      if (typeof plotDiv.on === 'function') {
        plotDiv.removeAllListeners && plotDiv.removeAllListeners('plotly_afterplot');
        plotDiv.on('plotly_afterplot', () => {
          bindPlotHandlers(plotDiv);
          bindNativePickFallback(plotDiv);
        });
      }
      setTimeout(() => {
        suppressRelayout = true;
        Plotly.Plots.resize(plotDiv);
        suppressRelayout = false;
      }, 50);

      // Always (re)attach handlers in one place
      bindPlotHandlers(plotDiv);
      bindNativePickFallback(plotDiv);
    }

    function renderLatestView(startOverride = null, endOverride = null) {
      const sel = document.getElementById('layerSelect');
      const layer = sel ? sel.value : 'raw';
      const slider = document.getElementById('key1_idx_slider');
      const idx = slider ? parseInt(slider.value, 10) : 0;
      const key1Val = key1Values[idx];

      if (latestSeismicData) {
        const startTrace = typeof startOverride === 'number'
          ? startOverride
          : (typeof renderedStart === 'number' ? renderedStart : 0);
        const endTrace = typeof endOverride === 'number'
          ? endOverride
          : (typeof renderedEnd === 'number'
            ? renderedEnd
            : latestSeismicData.length - 1);
        plotSeismicData(latestSeismicData, defaultDt, startTrace, endTrace);
        return;
      }

      if (
        latestWindowRender &&
        latestWindowRender.requestedLayer === layer &&
        latestWindowRender.key1 === key1Val
      ) {
        if (layer !== 'raw') {
          const pipelineKeyNow = window.latestPipelineKey || null;
          if ((latestWindowRender.pipelineKey || null) !== (pipelineKeyNow || null)) {
            return;
          }
        }
        if (latestWindowRender.mode === 'wiggle') {
          renderWindowWiggle(latestWindowRender);
        } else {
          renderWindowHeatmap(latestWindowRender);
        }
      }
    }

    async function fetchWindowAndPlot() {
      if (performance.now() < suppressUntil) return;
      if (!currentFileId || !sectionShape) return;
      const slider = document.getElementById('key1_idx_slider');
      if (!slider) return;
      const idx = parseInt(slider.value, 10);
      const key1Val = key1Values[idx];
      if (key1Val === undefined) return;

      const windowInfo = currentVisibleWindow();
      if (!windowInfo) return;

      const plotDiv = document.getElementById('plot');
      if (!plotDiv) return;

      const widthPx = plotDiv.clientWidth || plotDiv.offsetWidth || 1;
      const heightPx = plotDiv.clientHeight || plotDiv.offsetHeight || 1;
      const sel = document.getElementById('layerSelect');
      const requestedLayer = sel ? sel.value : 'raw';
      const isFbLayer = requestedLayer === 'fbprob';
      const wantWiggle = !isFbLayer && wantWiggleForWindow({
        tracesVisible: windowInfo.nTraces,
        samplesVisible: windowInfo.nSamples,
        widthPx,
      });

      let step_x;
      let step_y;
      if (wantWiggle) {
        step_x = 1;
        step_y = 1;
      } else {
        ({ step_x, step_y } = computeStepsForWindow({
          tracesVisible: windowInfo.nTraces,
          samplesVisible: windowInfo.nSamples,
          widthPx,
          heightPx,
        }));
      }

      const pipelineKeyNow = window.latestPipelineKey || null;
      const mode = wantWiggle ? 'wiggle' : 'heatmap';

      let effectiveLayer = requestedLayer;
      let tapLabel = null;
      if (requestedLayer !== 'raw') {
        if (pipelineKeyNow) {
          tapLabel = requestedLayer;
        } else {
          effectiveLayer = 'raw';
        }
      } else {
        effectiveLayer = 'raw';
      }

      if (!wantWiggle && effectiveLayer === 'raw' && latestSeismicData && step_x === 1 && step_y === 1) {
        return;
      }
      if (!wantWiggle && tapLabel && latestTapData[requestedLayer] && step_x === 1 && step_y === 1) {
        latestSeismicData = latestTapData[requestedLayer];
        renderLatestView(windowInfo.x0, windowInfo.x1);
        return;
      }

      const params = new URLSearchParams({
        file_id: currentFileId,
        key1_idx: String(key1Val),
        key1_byte: String(currentKey1Byte),
        key2_byte: String(currentKey2Byte),
        x0: String(windowInfo.x0),
        x1: String(windowInfo.x1),
        y0: String(windowInfo.y0),
        y1: String(windowInfo.y1),
        step_x: String(step_x),
        step_y: String(step_y),
      });
      if (tapLabel && pipelineKeyNow) {
        params.set('pipeline_key', pipelineKeyNow);
        params.set('tap_label', tapLabel);
      }

      if (windowFetchAbort) {
        try { windowFetchAbort.abort(); } catch (_) {}
      }
      const ac = new AbortController();
      windowFetchAbort = ac;
      const requestId = ++windowFetchToken;
      try {
        const res = await fetch(`/get_section_window_bin?${params.toString()}`, { signal: ac.signal });
        if (!res.ok) {
          console.warn('Window fetch failed', res.status);
          return;
        }
        const bin = new Uint8Array(await res.arrayBuffer());
        if (requestId !== windowFetchToken) return;
        if (windowFetchAbort !== ac) return;
        const obj = msgpack.decode(bin);
        const int8 = new Int8Array(obj.data.buffer);
        const values = Float32Array.from(int8, (v) => v / obj.scale);
        const shapeRaw = Array.isArray(obj.shape) ? obj.shape : Array.from(obj.shape ?? []);
        if (shapeRaw.length !== 2) {
          console.warn('Unexpected window shape', obj.shape);
          return;
        }
        const rows = Number(shapeRaw[0]);
        const cols = Number(shapeRaw[1]);
        const windowPayload = {
          key1: key1Val,
          requestedLayer,
          effectiveLayer,
          pipelineKey: tapLabel ? pipelineKeyNow : null,
          x0: windowInfo.x0,
          x1: windowInfo.x1,
          y0: windowInfo.y0,
          y1: windowInfo.y1,
          stepX: step_x,
          stepY: step_y,
          shape: [rows, cols],
          values,
          mode,
        };
        latestSeismicData = null;
        latestWindowRender = windowPayload;
        if (mode === 'wiggle') {
          renderWindowWiggle(windowPayload);
        } else {
          renderWindowHeatmap(windowPayload);
        }
      } catch (err) {
        if (!(err && err.name === 'AbortError')) {
          if (requestId === windowFetchToken) console.warn('Window fetch error', err);
        }
      } finally {
        if (windowFetchAbort === ac) windowFetchAbort = null;
      }
    }

    const scheduleWindowFetch = debounce(() => {
      fetchWindowAndPlot().catch((err) => console.warn('Window fetch failed', err));
    }, WINDOW_FETCH_DEBOUNCE_MS);

    function visibleTraceIndices(range, total) {
      let start = Math.floor(range[0]);
      let end = Math.ceil(range[1]);
      start = Math.max(0, start);
      end = Math.min(total - 1, end);
      return [start, end];
    }

    function plotSeismicData(seismic, dt, startTrace = 0, endTrace = seismic.length - 1) {
      const totalTraces = seismic.length;
      startTrace = Math.max(0, startTrace);
      endTrace = Math.min(totalTraces - 1, endTrace);
      const nTraces = endTrace - startTrace + 1;
      const nSamples = seismic[0].length;
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, totalTraces - 1];
      const visibleTraces = endTrace - startTrace + 1;
      const density = visibleTraces / widthPx;
      const mode = document.getElementById('layerSelect').value;
      const fbMode = mode === 'fbprob'; // 使っていないが残置可

      let traces = [];
      const gain = parseFloat(document.getElementById('gain').value) || 1.0;
      const AMP_LIMIT = 3.0;

      if (!fbMode && density < 0.1) {
        downsampleFactor = 1;
        const time = new Float32Array(nSamples);
        for (let t = 0; t < nSamples; t++) time[t] = t * dt;
        for (let i = startTrace; i <= endTrace; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            let val = raw[j] * gain;
            if (val > AMP_LIMIT) val = AMP_LIMIT;
            if (val < -AMP_LIMIT) val = -AMP_LIMIT;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'x+y', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, hoverinfo: 'skip', showlegend: false });
        }
      } else {
        const MAX_POINTS = 3_000_000;
        let factor = 1;
        while (Math.floor(nTraces / factor) * Math.floor(nSamples / factor) > MAX_POINTS) factor++;
        const nTracesDS = Math.floor(nTraces / factor);
        const nSamplesDS = Math.floor(nSamples / factor);
        console.log('Downsampling factor:', factor);
        console.log('Final dimensions:', nTracesDS, 'x', nSamplesDS);

        const time = new Float32Array(nSamplesDS);
        for (let t = 0; t < nSamplesDS; t++) time[t] = t * dt * factor;

        const zData = Array.from({ length: nSamplesDS }, () => new Float32Array(nTracesDS));

        for (let i = startTrace, col = 0; col < nTracesDS; i += factor, col++) {
          const trace = seismic[i];
          for (let j = 0, row = 0; row < nSamplesDS; j += factor, row++) {
            if (fbMode) {
              const val = trace[j] * 255;
              zData[row][col] = val;
            } else {
              let val = trace[j] * gain;
              if (val > AMP_LIMIT) val = AMP_LIMIT;
              if (val < -AMP_LIMIT) val = -AMP_LIMIT;
              zData[row][col] = val;
            }
          }
        }

        const zMin = fbMode ? 0 : -AMP_LIMIT;
        const zMax = fbMode ? 255 : AMP_LIMIT;

        const xVals = new Float32Array(nTracesDS);
        for (let i = 0; i < nTracesDS; i++) xVals[i] = startTrace + i * factor;
        downsampleFactor = factor;

        const cmName = document.getElementById('colormap')?.value || 'Greys';
        const reverse = document.getElementById('cmReverse')?.checked || false;
        const cm = COLORMAPS[cmName] || 'Greys';
        const isDiv = cmName === 'RdBu' || cmName === 'BWR';

        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: cm,
          reversescale: reverse,
          zmin: zMin,
          zmax: zMax,
          ...(fbMode ? {} : (isDiv ? { zmid: 0 } : {})),
          showscale: false,
          hoverinfo: 'x+y',
          hovertemplate: '',
        }];
      }

      const layout = {
        xaxis: {
          title: 'Trace', showgrid: false, tickfont: { color: '#000' }, titlefont: { color: '#000' },
          autorange: !savedXRange, ...(savedXRange ? { range: savedXRange } : {})
        },
        yaxis: {
          title: 'Time (s)', showgrid: false, tickfont: { color: '#000' }, titlefont: { color: '#000' },
          autorange: false, range: savedYRange ?? [nSamples * dt, 0]
        },
        paper_bgcolor: '#fff', plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: isPickMode ? false : 'zoom',
        ...(fbMode ? { title: 'First-break Probability' } : {}),
      };

      const manualShapes = picks.map(p => ({
        type: 'line',
        x0: p.trace - 0.4, x1: p.trace + 0.4,
        y0: p.time, y1: p.time,
        line: { color: 'red', width: 2 },
      }));

      const showPred = document.getElementById('showFbPred')?.checked;
      const predShapes = (showPred ? predictedPicks : [])
        .filter(p => p.trace >= startTrace && p.trace <= endTrace)
        .map(p => ({
          type: 'line',
          x0: p.trace - 0.4, x1: p.trace + 0.4,
          y0: p.time, y1: p.time,
          line: { color: '#1f77b4', width: 5, dash: 'dot' },
        }));

      layout.shapes = [...manualShapes, ...predShapes];
      layout.dragmode = isPickMode ? false : 'zoom';

      Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: !isPickMode,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false }
      });
      if (typeof plotDiv.on === 'function') {
        plotDiv.removeAllListeners && plotDiv.removeAllListeners('plotly_afterplot');
        plotDiv.on('plotly_afterplot', () => {
          bindPlotHandlers(plotDiv);
          bindNativePickFallback(plotDiv);
        });
      }

      setTimeout(() => {
        suppressRelayout = true;
        Plotly.Plots.resize(plotDiv);
        suppressRelayout = false;
      }, 50);
      renderedStart = startTrace;
      renderedEnd = endTrace;
      console.log(`Rendered traces ${startTrace}-${endTrace}`);

      // Always (re)attach handlers in one place
      bindPlotHandlers(plotDiv);
      bindNativePickFallback(plotDiv);
    }

    function pickOnTrace(trace) {
      return picks.findIndex(p => Math.round(p.trace) === trace);
    }

    async function handleRelayout(ev) {
      if (typeof suppressRelayout !== 'undefined' && suppressRelayout) return;
      const plotDiv = document.getElementById('plot');
      if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
        savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
      } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
        savedXRange = null;
        savedYRange = null;
        // also drop any “previous window” fallback so we don’t creep out again
        renderedStart = null;
        renderedEnd = null;
        // next currentVisibleWindow() call must use full extent, no padding
        forceFullExtentOnce = true;
      }

      if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
        const y0 = ev['yaxis.range[0]'];
        const y1 = ev['yaxis.range[1]'];
        savedYRange = y0 > y1 ? [y0, y1] : [y1, y0];
      }

      if (latestSeismicData) {
        const [s, e] = savedXRange ? visibleTraceIndices(savedXRange, latestSeismicData.length)
          : [0, latestSeismicData.length - 1];
        if (s !== renderedStart || e !== renderedEnd) {
          renderLatestView(s, e);
        } else {
          renderLatestView();
        }
      } else if (latestWindowRender) {
        renderLatestView();
      }

      if (Array.isArray(ev.shapes)) {
        // 予測(青点線)は保存しない。赤のみ保存。
        const onlyManual = ev.shapes.filter(s => s.line && s.line.color === 'red');
        const newPicks = onlyManual.map(s => ({
          trace: (s.x0 + s.x1) / 2,
          time: (s.y0 + s.y1) / 2
        }));

        const oldTraces = new Set(picks.map(p => Math.round(p.trace)));
        const newTraces = new Set(newPicks.map(p => Math.round(p.trace)));
        for (const t of oldTraces) {
          if (!newTraces.has(t)) {
            await deletePick(t);
          }
        }
        picks = newPicks;
      }
      scheduleWindowFetch();
    }

    window.addEventListener('DOMContentLoaded', () => {
      loadSettings();
      const plotDiv = document.getElementById('plot');
      if (plotDiv && typeof plotDiv.on === 'function') {
        // Re-bind after every Plotly internal “afterplot” (e.g., react/resize/layout changes)
        plotDiv.on('plotly_afterplot', () => {
          bindPlotHandlers(plotDiv);
          bindNativePickFallback(plotDiv);
        });
      }
    });

    // Toggle between raw and first tap with the "n" key
    window.addEventListener('keydown', (e) => {
      if (
        e.key.toLowerCase() === 'n' &&
        !e.ctrlKey && !e.altKey && !e.metaKey &&
        !['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)
      ) {
        const sel = document.getElementById('layerSelect');
        if (!sel) return;
        if (sel.options.length > 1) {
          sel.value = sel.value === 'raw' ? sel.options[1].value : 'raw';
          drawSelectedLayer();
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'Shift') {
        linePickStart = null;
      }
    });
  </script>
</body>

</html>
