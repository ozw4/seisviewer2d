<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Upload SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let savedXRange = null;
    let savedYRange = null;
    let latestSeismicData = null;
    const defaultDt = 0.004;

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

    async function fetchKey1Values() {
      const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
      if (res.ok) {
        const data = await res.json();
        key1Values = data.values;
        setKey1SliderMax(key1Values.length - 1);
        document.getElementById('key1_idx_display').min = key1Values[0];
        document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
        document.getElementById('key1_idx_slider').value = 0;
        updateKey1Display();
      }
    }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchAndPlot();
      }
    }

    async function fetchAndPlot() {
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      const url = `/get_section?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
      const res = await fetch(url);
      if (!res.ok) {
        alert('Failed to load section');
        return;
      }
      const json = await res.json();
      latestSeismicData = json.section;
      plotSeismicData(latestSeismicData, defaultDt);
    }

    function plotSeismicData(seismic, dt) {
      const nTraces = seismic.length;
      const nSamples = seismic[0].length;
      const time = new Float32Array(nSamples);
      for (let t = 0; t < nSamples; t++) {
        time[t] = t * dt;
      }
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, nTraces - 1];
      const visibleTraces = Math.abs(xRange[1] - xRange[0]) + 1;
      const density = visibleTraces / widthPx;

      let traces = [];
      const gain = 1.0;

      if (density < 0.1) {
        for (let i = 0; i < nTraces; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            const val = raw[j] * gain;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, showlegend: false });
        }
      } else {
        const zData = Array.from({ length: nSamples }, () => new Float32Array(nTraces));
        let zMin = Infinity;
        let zMax = -Infinity;
        for (let i = 0; i < nTraces; i++) {
          const trace = seismic[i];
          for (let j = 0; j < nSamples; j++) {
            const val = trace[j];
            zData[j][i] = val;
            if (val < zMin) zMin = val;
            if (val > zMax) zMax = val;
          }
        }
        const xVals = new Float32Array(nTraces);
        for (let i = 0; i < nTraces; i++) xVals[i] = i;
        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: 'Gray',
          zmin: zMin,
          zmax: zMax,
          showscale: false,
          hoverinfo: 'skip'
        }];
      }

      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          ...(savedXRange ? { range: savedXRange } : {})
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [nSamples * dt, 0]  // reversed を手動設定
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: false
      };

      Plotly.react(plotDiv, traces, layout, { responsive: true });


      plotDiv.on('plotly_relayout', ev => {
              let xChanged = false;
              if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
                const newRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
                xChanged = !savedXRange || savedXRange[0] !== newRange[0] || savedXRange[1] !== newRange[1];
                savedXRange = newRange;
              } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
                xChanged = savedXRange !== null;
                savedXRange = null;
                savedYRange = null;
              }

              if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
                savedYRange = [ev['yaxis.range[0]'], ev['yaxis.range[1]']];
              }

              if (xChanged && latestSeismicData) {
                plotSeismicData(latestSeismicData, defaultDt);
              }

            });
    }


    window.addEventListener('DOMContentLoaded', loadSettings);
  </script>
</body>
</html>
