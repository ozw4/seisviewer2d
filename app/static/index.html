<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Upload SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
    <progress id="preload_progress" value="0" max="0" style="width: 150px;"></progress>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script src="/static/pako.min.js"></script>
  <script src="/static/msgpack.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let savedXRange = null;
    let savedYRange = null;
    let latestSeismicData = null;
    const defaultDt = 0.004;
    const MAX_CACHE = 50;
    const cache = new Map(); // key -> {scale, buf:Int8Array}
    let sectionShape = null;
    let renderedStart = null;
    let renderedEnd = null;

    function putCache(key, scale, buf){
      if (cache.size >= MAX_CACHE) cache.delete(cache.keys().next().value);
      cache.set(key, {scale, buf});
    }
    function getCacheF32(key){
      if(!cache.has(key)) return null;
      const {scale, buf} = cache.get(key);
      cache.delete(key); cache.set(key,{scale,buf});   // refresh LRU
      return toFloat32(buf, scale);
    }
    function toFloat32(buf, scale){
      return Float32Array.from(buf, v => v/scale);
    }

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

    async function fetchKey1Values() {
      const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
      if (res.ok) {
        const data = await res.json();
        key1Values = data.values;
        setKey1SliderMax(key1Values.length - 1);
        document.getElementById('key1_idx_display').min = key1Values[0];
        document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
        document.getElementById('key1_idx_slider').value = 0;
        updateKey1Display();
      }
    }

    async function preloadSections() {
      const progress = document.getElementById('preload_progress');
      progress.max = key1Values.length;
      let loaded = 0;
      for (const key1Val of key1Values) {
        if (cache.has(key1Val)) {
          loaded++;
          progress.value = loaded;
          console.log(`Preloaded ${loaded}/${key1Values.length}`);
          continue;
        }
        try {
          const url = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
          const res = await fetch(url);
          if (res.ok) {
            const bin = new Uint8Array(await res.arrayBuffer());
            const obj = msgpack.decode(bin);
            const int8 = new Int8Array(obj.data.buffer);
            putCache(key1Val, obj.scale, int8);
            if (!sectionShape) sectionShape = obj.shape;
          } else {
            console.warn(`Failed to preload section for key1 ${key1Val}`);
          }
        } catch (err) {
          console.warn(`Error preloading section for key1 ${key1Val}`, err);
        }
        loaded++;
        progress.value = loaded;
        console.log(`Preloaded ${loaded}/${key1Values.length}`);
      }
      console.log('Finished preloading sections');
    }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchAndPlot();
        preloadSections();
      }
    }

  async function fetchAndPlot() {
    const t0_all = performance.now();               // ★ 全体計測開始

    /*─────────────────── 取得する key1 決定 ───────────────────*/
    const index = +document.getElementById('key1_idx_slider').value;
    const key1Val = key1Values[index];

    let t_net = 0, t_decode = 0, t_f32 = 0, t_plot = 0;   // メトリクス初期化
    let f32;

    /*──────────── LRU キャッシュ (Int8) ヒットチェック ───────────*/
    f32 = getCacheF32(key1Val);
    if (!f32) {
      /*────────── ネットワーク取得 ──────────*/
      const urlBin = `/get_section_bin?file_id=${currentFileId}` +
        `&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}` +
        `&key2_byte=${currentKey2Byte}`;

      const t0_net = performance.now();
      const res = await fetch(urlBin);
      const bin = new Uint8Array(await res.arrayBuffer());
      t_net = performance.now() - t0_net;                  // ★ ネット転送

      /*────────── msgpack デコード ──────────*/
      const t0_dec = performance.now();
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      t_decode = performance.now() - t0_dec;           // ★ デコード

      /*────────── LRU に Int8 を保存 ──────────*/
      putCache(key1Val, obj.scale, int8);
      sectionShape = obj.shape;            // たとえ null でも上書き

      /*────────── Int8 → Float32 変換 ────────*/
      const t0_f32 = performance.now();
      f32 = toFloat32(int8, obj.scale);
      t_f32 = performance.now() - t0_f32;           // ★ 変換
    }

    /*───────── Float32Array を 2 次元トレース配列へ ─────────*/
    const [nTraces, nSamples] = sectionShape;
    const traces = new Array(nTraces);
    for (let i = 0; i < nTraces; i++) {
      traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
    }
    latestSeismicData = traces;

    /*───────── 既存ロジックで描画 ─────────*/
    const [s, e] = savedXRange
      ? visibleTraceIndices(savedXRange, latestSeismicData.length)
      : [0, latestSeismicData.length - 1];

    const t0_plot = performance.now();
    plotSeismicData(latestSeismicData, defaultDt, s, e);
    t_plot = performance.now() - t0_plot;                   // ★ 描画

    /*───────── メトリクスをまとめて表示 ─────────*/
    console.table([{
      key1: key1Val,
      net_ms: t_net.toFixed(1),
      decode_ms: t_decode.toFixed(1),
      f32_ms: t_f32.toFixed(1),
      plot_ms: t_plot.toFixed(1),
      total_ms: (performance.now() - t0_all).toFixed(1)
    }]);
  }

    function visibleTraceIndices(range, total) {
      let start = Math.floor(range[0]);
      let end = Math.ceil(range[1]);
      start = Math.max(0, start);
      end = Math.min(total - 1, end);
      return [start, end];
    }

    function plotSeismicData(seismic, dt, startTrace = 0, endTrace = seismic.length - 1) {
      const totalTraces = seismic.length;
      startTrace = Math.max(0, startTrace);
      endTrace = Math.min(totalTraces - 1, endTrace);
      const nTraces = endTrace - startTrace + 1;
      const nSamples = seismic[0].length;
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, totalTraces - 1];
      const visibleTraces = endTrace - startTrace + 1;
      const density = visibleTraces / widthPx;

      let traces = [];
      const gain = 1.0;

      if (density < 0.1) {
        const time = new Float32Array(nSamples);
        for (let t = 0; t < nSamples; t++) {
          time[t] = t * dt;
        }
        for (let i = startTrace; i <= endTrace; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            const val = raw[j] * gain;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, showlegend: false });
        }
      } else {
        const MAX_POINTS = 3_000_000;
        let factor = 1;
        while (Math.floor(nTraces / factor) * Math.floor(nSamples / factor) > MAX_POINTS) {
          factor++;
        }

        const nTracesDS = Math.floor(nTraces / factor);
        const nSamplesDS = Math.floor(nSamples / factor);
        console.log('Downsampling factor:', factor);
        console.log('Final dimensions:', nTracesDS, 'x', nSamplesDS);

        const time = new Float32Array(nSamplesDS);
        for (let t = 0; t < nSamplesDS; t++) {
          time[t] = t * dt * factor;
        }

        const zData = Array.from({ length: nSamplesDS }, () => new Float32Array(nTracesDS));
        let zMin = Infinity;
        let zMax = -Infinity;
        for (let i = startTrace, col = 0; col < nTracesDS; i += factor, col++) {
          const trace = seismic[i];
          for (let j = 0, row = 0; row < nSamplesDS; j += factor, row++) {
            const val = trace[j];
            zData[row][col] = val;
            if (val < zMin) zMin = val;
            if (val > zMax) zMax = val;
          }
        }
        const xVals = new Float32Array(nTracesDS);
        for (let i = 0; i < nTracesDS; i++) xVals[i] = startTrace + i * factor;
        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: 'Gray',
          zmin: zMin,
          zmax: zMax,
          showscale: false,
          hoverinfo: 'skip'
        }];
      }

      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          ...(savedXRange ? { range: savedXRange } : {})
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [nSamples * dt, 0]  // reversed を手動設定
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: false
      };

      Plotly.react(plotDiv, traces, layout, { responsive: true });
      setTimeout(() => Plotly.Plots.resize(plotDiv), 50);
      renderedStart = startTrace;
      renderedEnd = endTrace;
      console.log(`Rendered traces ${startTrace}-${endTrace}`);

      plotDiv.removeAllListeners('plotly_relayout');
      plotDiv.on('plotly_relayout', ev => {
        if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
          savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
        } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
          savedXRange = null;
          savedYRange = null;
        }

        if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
          const y0 = ev['yaxis.range[0]'];
          const y1 = ev['yaxis.range[1]'];
          savedYRange = y0 > y1 ? [y0, y1] : [y1, y0]; // 大きい方を上に（逆順）
        }

        if (latestSeismicData) {
          const [s, e] = savedXRange ? visibleTraceIndices(savedXRange, latestSeismicData.length) : [0, latestSeismicData.length - 1];
          if (s !== renderedStart || e !== renderedEnd) {
            plotSeismicData(latestSeismicData, defaultDt, s, e);
          }
        }
      });
    }


    window.addEventListener('DOMContentLoaded', loadSettings);
  </script>
</body>
</html>
