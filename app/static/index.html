<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Upload SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let savedXRange = null;
    let savedYRange = null;

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

    async function fetchKey1Values() {
      const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
      if (res.ok) {
        const data = await res.json();
        key1Values = data.values;
        setKey1SliderMax(key1Values.length - 1);
        document.getElementById('key1_idx_display').min = key1Values[0];
        document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
        document.getElementById('key1_idx_slider').value = 0;
        updateKey1Display();
      }
    }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchAndPlot();
      }
    }

    async function fetchAndPlot() {
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      const url = `/get_section?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
      const res = await fetch(url);
      if (!res.ok) {
        alert('Failed to load section');
        return;
      }
      const json = await res.json();
      plotSeismicData(json.section, 0.004);
    }

    function plotSeismicData(seismic, dt) {
      const nTraces = seismic.length;
      const nSamples = seismic[0].length;
      const time = Array.from({ length: nSamples }, (_, i) => i * dt);
      const traces = [];
      const gain = 1.0;

      for (let i = 0; i < nTraces; i++) {
        const raw = seismic[i];
        const maxAbs = Math.max(...raw.map(v => Math.abs(v))) || 1.0;
        const traceData = raw.map(v => (v / maxAbs) * gain);
        const positiveOnly = traceData.map(val => Math.max(0, val));
        const shiftedFullX = traceData.map(x => x + i);
        const shiftedPosX = positiveOnly.map(x => x + i);
        const baseX = Array(nSamples).fill(i);

        traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'skip', showlegend: false });
        traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
        traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, showlegend: false });
      }

      const plotDiv = document.getElementById('plot');
      Plotly.newPlot(plotDiv, traces, {
        yaxis: { autorange: 'reversed', title: 'Time (s)', showgrid: false, tickfont: { color: '#000' }, titlefont: { color: '#000' } },
        xaxis: {  },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: false
      }, { responsive: true }).then(() => {
        if (savedXRange) {
          Plotly.relayout(plotDiv, { 'xaxis.range': savedXRange });
        }
        if (savedYRange) {
          Plotly.relayout(plotDiv, { 'yaxis.range': savedYRange });
        }
      });

      plotDiv.on('plotly_relayout', ev => {
              if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
                savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
              } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
                savedXRange = null;
              }

              if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
                savedYRange = [ev['yaxis.range[0]'], ev['yaxis.range[1]']];
              } else if ('yaxis.autorange' in ev && ev['yaxis.autorange'] === true) {
                savedYRange = null;
              }
            });
    }


    window.addEventListener('DOMContentLoaded', loadSettings);
  </script>
</body>
</html>
