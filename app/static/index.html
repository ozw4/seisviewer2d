<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
    #pickModeBtn.active {
      background: #007bff;
      color: #fff;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Upload SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
    <button id="pickModeBtn" onclick="togglePickMode()">Pick Mode: OFF</button>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script src="/static/pako.min.js"></script>
  <script src="/static/msgpack.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let savedXRange = null;
    let savedYRange = null;
    let latestSeismicData = null;
    const defaultDt = 0.002;
    const PREFETCH_WIDTH = 3;   // ±10
    const FALLBACK_MAX = 8;  // API 無い場合
    const HARD_LIMIT_BYTES = 1000 * 1024 * 1024; // 800MB

    const cache = new Map(); // key -> {scale, buf:Int8Array}
    const inflight = new Map();
    let sectionShape = null;
    let renderedStart = null;
    let renderedEnd = null;
    let picks = [];
    let downsampleFactor = 1;
    let isPickMode = false;
    let linePickStart = null;
    let deleteRangeStart = null;

    function togglePickMode() {
      isPickMode = !isPickMode;
      const btn = document.getElementById('pickModeBtn');
      btn.textContent = isPickMode ? 'Pick Mode: ON' : 'Pick Mode: OFF';
      btn.classList.toggle('active', isPickMode);
      linePickStart = null;
      deleteRangeStart = null;
      if (latestSeismicData) {
        plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
      }
    }

  function toFloat32(buf, scale) {
    return Float32Array.from(buf, v => v / scale);
  }
  function putCache(key, scale, buf) {
    const f32 = Float32Array.from(buf, v => v / scale);
    cache.set(key, { scale, buf, f32 });
    //cache.set(key, { scale, buf });

    const canCheckMemory =
      performance.memory &&
      performance.memory.usedJSHeapSize > 0;

    const used = canCheckMemory ? performance.memory.usedJSHeapSize : 0;

    console.log('--- putCache called ---');
    console.log('Added key:', cache.keys());
    console.log('Cache size:', cache.size);
    if (canCheckMemory) {
      const total = performance.memory.totalJSHeapSize;
      const ratio = used / total;
      console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB`);

    } else {
      console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB (fallback, no total)`);
    }

    if (used > HARD_LIMIT_BYTES) {
      console.warn(`⚠ Memory limit exceeded! (${(used / 1024 / 1024).toFixed(1)} MB > 800 MB)`);
      let removed = 0;
      while (cache.size > 1) {
        const removedKey = cache.keys().next().value;
        const entry = cache.get(removedKey);

        // 🔽 メモリ解放を促すために参照を切る
        if (entry) {
          entry.f32 = null;
          entry.buf = null;
        }

        cache.delete(removedKey);
        removed++;
      }
      console.warn(`Evicted ${removed} items due to hard heap limit.`);
      console.log('Remaining keys:', Array.from(cache.keys()));
    }

    console.log('------------------------');
  }
    function getCacheF32(key) {
      if (!cache.has(key)) return null;
      const entry = cache.get(key);
      cache.delete(key); cache.set(key, entry); // refresh LRU
      return entry.f32;
    }

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

      async function fetchKey1Values() {
        const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
        if (res.ok) {
          const data = await res.json();
          key1Values = data.values;
          setKey1SliderMax(key1Values.length - 1);
          document.getElementById('key1_idx_display').min = key1Values[0];
          document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
          document.getElementById('key1_idx_slider').value = 0;
          updateKey1Display();
        }
      }

      function prefetchAround(centerIdx) {
        for (const ctrl of inflight.values()) ctrl.abort();
        inflight.clear();
        const start = Math.max(0, centerIdx - PREFETCH_WIDTH);
        const end = Math.min(key1Values.length - 1, centerIdx + PREFETCH_WIDTH);
        const scheduler = cb => {
          if ('requestIdleCallback' in window) {
            requestIdleCallback(cb);
          } else {
            setTimeout(cb, 0);
          }
        };
        for (let i = start; i <= end; i++) {
          if (i === centerIdx) continue;
          const key = key1Values[i];
          if (cache.has(key) || inflight.has(key)) continue;
          const controller = new AbortController();
          inflight.set(key, controller);
          scheduler(async () => {
            try {
              const url = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
              const res = await fetch(url, { signal: controller.signal });
              if (res.ok) {
                const bin = new Uint8Array(await res.arrayBuffer());
                const obj = msgpack.decode(bin);
                const int8 = new Int8Array(obj.data.buffer);
                putCache(key, obj.scale, int8);
                if (!sectionShape) sectionShape = obj.shape;
              }
            } catch (err) {
              if (err.name !== 'AbortError') {
                console.warn('Prefetch failed', key, err);
              }
            } finally {
              inflight.delete(key);
            }
          });
        }
      }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchPicks();
        await fetchAndPlot();
      }
    }

  async function fetchPicks() {
    if (!currentFileId) return;
    const idx = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[idx];
    try {
      const res = await fetch(`/picks?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`);
      if (res.ok) {
        const data = await res.json();
        picks = (data.picks || []).map(p => ({ trace: p.trace, time: p.time }));
      }
    } catch (e) {
      console.error('Failed to fetch picks', e);
    }
  }

  async function postPick(trace, time) {
    const idx = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[idx];
    try {
      await fetch('/picks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_id: currentFileId, trace, time, key1_idx: key1Val, key1_byte: currentKey1Byte })
      });
    } catch (e) {
      console.error('Failed to post pick', e);
    }
  }

  async function deletePick(trace) {
    const idx = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[idx];
    try {
      await fetch(`/picks?file_id=${currentFileId}&trace=${trace}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`, { method: 'DELETE' });
    } catch (e) {
      console.error('Failed to delete pick', e);
    }
  }

  async function fetchAndPlot() {
    console.log('--- fetchAndPlot start ---');
    console.time('Total fetchAndPlot');

    const index = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[index];

    await fetchPicks();

    console.time('Cache lookup');
    let f32 = getCacheF32(key1Val);
    console.timeEnd('Cache lookup');

    let traces;

    if (f32) {
      console.time('Decode from cache');
      const [nTraces, nSamples] = sectionShape;
      traces = new Array(nTraces);
      for (let i = 0; i < nTraces; i++) {
        traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
      }
      console.timeEnd('Decode from cache');
      latestSeismicData = traces;
    } else {
      console.time('Fetch binary');
      const urlBin = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
      const res = await fetch(urlBin);
      if (!res.ok) {
        alert('Failed to load section');
        return;
      }
      const bin = new Uint8Array(await res.arrayBuffer());
      console.timeEnd('Fetch binary');

      console.time('Decode & cache');
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      putCache(key1Val, obj.scale, int8);
      sectionShape = obj.shape;
      const tmp = toFloat32(int8, obj.scale);
      const [nTraces, nSamples] = sectionShape;
      traces = new Array(nTraces);
      for (let i = 0; i < nTraces; i++) {
        traces[i] = tmp.subarray(i * nSamples, (i + 1) * nSamples);
      }
      console.timeEnd('Decode & cache');
      latestSeismicData = traces;
    }

    console.time('Plotting');
    const [s, e] = savedXRange ? visibleTraceIndices(savedXRange, latestSeismicData.length) : [0, latestSeismicData.length - 1];
    plotSeismicData(latestSeismicData, defaultDt, s, e);
    console.timeEnd('Plotting');

    console.time('Prefetch');
    prefetchAround(index);
    console.timeEnd('Prefetch');

    console.timeEnd('Total fetchAndPlot');
    console.log('--- fetchAndPlot end ---');
  }

    function visibleTraceIndices(range, total) {
      let start = Math.floor(range[0]);
      let end = Math.ceil(range[1]);
      start = Math.max(0, start);
      end = Math.min(total - 1, end);
      return [start, end];
    }

    function plotSeismicData(seismic, dt, startTrace = 0, endTrace = seismic.length - 1) {
      const totalTraces = seismic.length;
      startTrace = Math.max(0, startTrace);
      endTrace = Math.min(totalTraces - 1, endTrace);
      const nTraces = endTrace - startTrace + 1;
      const nSamples = seismic[0].length;
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, totalTraces - 1];
      const visibleTraces = endTrace - startTrace + 1;
      const density = visibleTraces / widthPx;

      let traces = [];
      const gain = 1.0;

      if (density < 0.1) {
        downsampleFactor = 1;
        const time = new Float32Array(nSamples);
        for (let t = 0; t < nSamples; t++) {
          time[t] = t * dt;
        }
        for (let i = startTrace; i <= endTrace; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            const val = raw[j] * gain;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'x+y', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, hoverinfo: 'skip',showlegend: false });
        }
      } else {
        const MAX_POINTS = 3_000_000;
        let factor = 1;
        while (Math.floor(nTraces / factor) * Math.floor(nSamples / factor) > MAX_POINTS) {
          factor++;
        }

        const nTracesDS = Math.floor(nTraces / factor);
        const nSamplesDS = Math.floor(nSamples / factor);
        console.log('Downsampling factor:', factor);
        console.log('Final dimensions:', nTracesDS, 'x', nSamplesDS);

        const time = new Float32Array(nSamplesDS);
        for (let t = 0; t < nSamplesDS; t++) {
          time[t] = t * dt * factor;
        }

        const zData = Array.from({ length: nSamplesDS }, () => new Float32Array(nTracesDS));
        let zMin = Infinity;
        let zMax = -Infinity;
        for (let i = startTrace, col = 0; col < nTracesDS; i += factor, col++) {
          const trace = seismic[i];
          for (let j = 0, row = 0; row < nSamplesDS; j += factor, row++) {
            const val = trace[j];
            zData[row][col] = val;
            if (val < zMin) zMin = val;
            if (val > zMax) zMax = val;
          }
        }
        const xVals = new Float32Array(nTracesDS);
        for (let i = 0; i < nTracesDS; i++) xVals[i] = startTrace + i * factor;
        downsampleFactor = factor;
        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: 'Greys',
          zmin: zMin,
          zmax: zMax,
          showscale: false,
          hoverinfo: 'x+y',
          hovertemplate: '',
        }];
      }

      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          ...(savedXRange ? { range: savedXRange } : {})
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [nSamples * dt, 0]  // reversed を手動設定
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: isPickMode ? false : 'zoom'
      };
        layout.shapes = picks.map(p => ({
          type: 'line',
          x0: p.trace - 0.4,
          x1: p.trace + 0.4,
          y0: p.time,
          y1: p.time,
          line: { color: 'red', width: 2 }
        }));

      Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: true,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false }
      });
      setTimeout(() => Plotly.Plots.resize(plotDiv), 50);
      renderedStart = startTrace;
      renderedEnd = endTrace;
      console.log(`Rendered traces ${startTrace}-${endTrace}`);

      plotDiv.removeAllListeners('plotly_relayout');
      plotDiv.removeAllListeners('plotly_click');
      plotDiv.on('plotly_relayout', handleRelayout);
      if (isPickMode) {
        plotDiv.on('plotly_click', handlePlotClick);
      }
    }

      function pickOnTrace(trace) {
        return picks.findIndex(p => Math.round(p.trace) === trace);
      }

    async function handlePlotClick(ev) {
      if (!isPickMode) return;
      console.log('🔥 plotly_click fired', ev);
      const plotDiv = document.getElementById('plot');
      if (!plotDiv || !ev.event || !ev.event.clientX) {
        console.warn('⚠️ plotDiv or event data not available.');
        return;
      }

      const dt = defaultDt * downsampleFactor;

      // -------- クリック位置を取得し、軸座標に変換 --------
      const rect = plotDiv.getBoundingClientRect();
      const xpx = ev.event.clientX - rect.left;
      const ypx = ev.event.clientY - rect.top;

      const xData = plotDiv._fullLayout.xaxis.p2d(xpx);
      const yData = plotDiv._fullLayout.yaxis.p2d(ypx);

      // -------- trace / time を整数グリッドにスナップ --------
      const trace = Math.round(ev.points[0].x);
      const time = Math.round(ev.points[0].y / dt) * dt;

      // -------- ログ --------
      console.group('🖱 Actual Click Data');
      console.log('clientX / Y:', ev.event.clientX, ev.event.clientY);
      console.log('pixel offset:', xpx, ypx);
      console.log('xData (trace):', xData);
      console.log('yData (time):', yData);
      console.log('Snapped trace:', trace);
      console.log('Snapped time:', time);
      console.groupEnd();

        // -------- Ctrl+クリックで範囲削除 --------
        if (ev.event.ctrlKey) {
          if (deleteRangeStart === null) {
            deleteRangeStart = trace;
            linePickStart = null;
            return;
          }
          const x0 = deleteRangeStart;
          deleteRangeStart = null;
          const x1 = trace;
          const start = Math.min(x0, x1);
          const end = Math.max(x0, x1);
          const toDelete = picks.filter(p => Math.round(p.trace) >= start && Math.round(p.trace) <= end);
          const promises = toDelete.map(p => deletePick(Math.round(p.trace)));
          picks = picks.filter(p => Math.round(p.trace) < start || Math.round(p.trace) > end);
          await Promise.all(promises);
          plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
          return;
        }

        // -------- Shift+クリックでラインピック --------
        if (ev.event.shiftKey) {
          if (!linePickStart) {
            linePickStart = { trace, time };
            deleteRangeStart = null;
            return;
          }

          const { trace: x0, time: y0 } = linePickStart;
          linePickStart = null;
          const x1 = trace;
          const y1 = time;
          const xStart = Math.round(Math.min(x0, x1));
          const xEnd = Math.round(Math.max(x0, x1));
          const slope = x1 === x0 ? 0 : (y1 - y0) / (x1 - x0);
          const promises = [];
          for (let x = xStart; x <= xEnd; x++) {
            const y = x1 === x0 ? y1 : y0 + slope * (x - x0);
            const snapped = Math.round(y / dt) * dt;
            const idx = pickOnTrace(x);
            if (idx >= 0) {
              promises.push(deletePick(x));
              picks.splice(idx, 1);
            }
            picks.push({ trace: x, time: snapped });
            promises.push(postPick(x, snapped));
          }
          await Promise.all(promises);
          plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
          return;
        }

        // -------- 通常クリックで単一ピック --------
        linePickStart = null;
        deleteRangeStart = null;
        const idx = pickOnTrace(trace);
        const promises = [];
        if (idx >= 0) {
          promises.push(deletePick(trace));
          picks.splice(idx, 1);
        }
        picks.push({ trace, time });
        promises.push(postPick(trace, time));
        await Promise.all(promises);
        plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
      }

    async function handleRelayout(ev) {
      const plotDiv = document.getElementById('plot');
      if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
        savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
      } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
        savedXRange = null;
        savedYRange = null;
      }

      if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
        const y0 = ev['yaxis.range[0]'];
        const y1 = ev['yaxis.range[1]'];
        savedYRange = y0 > y1 ? [y0, y1] : [y1, y0];
      }

      if (latestSeismicData) {
        const [s, e] = savedXRange
          ? visibleTraceIndices(savedXRange, latestSeismicData.length)
          : [0, latestSeismicData.length - 1];
        if (s !== renderedStart || e !== renderedEnd) {
          plotSeismicData(latestSeismicData, defaultDt, s, e);
        }
      }

      if (Array.isArray(ev.shapes)) {
        const newPicks = ev.shapes.map(s => ({ trace: (s.x0 + s.x1) / 2, time: (s.y0 + s.y1) / 2 }));
        const oldTraces = new Set(picks.map(p => Math.round(p.trace)));
        const newTraces = new Set(newPicks.map(p => Math.round(p.trace)));
        for (const t of oldTraces) {
          if (!newTraces.has(t)) {
            await deletePick(t);
          }
        }
        picks = newPicks;
      }
    }

    window.addEventListener('DOMContentLoaded', loadSettings);
  </script>
</body>
</html>
