<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<head>
  <title>Seismic Wiggle Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background: #f0f0f0;
      padding: 0.8em 1.2em;
      font-size: 1.2em;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #controls {
      padding: 0.5em 1em;
      background: #fafafa;
      border-bottom: 1px solid #ccc;
    }
    input,
    button {
      font-size: 1em;
      padding: 0.2em 0.4em;
      margin-right: 0.5em;
    }
    #pickModeBtn.active {
      background: #007bff;
      color: #fff;
    }
    .denoiseParam {
      display: none;
    }
    .bpfParam {
      display: none;
    }
    #denoiseSettingsDialog {
      padding: 1em;
      border: 1px solid #888;
    }
    #denoiseSettingsDialog form label {
      display: block;
      margin: 0.5em 0;
    }
  </style>
</head>
<body>
  <header>
    <span>Seismic Wiggle Viewer</span>
    <a href="/upload">Open SEG-Y</a>
  </header>
  <input type="hidden" id="file_id" />
  <div id="controls" style="padding: 1em; background: #f8f8f8; display: flex; gap: 1em; align-items: center;">
    <label for="key1_idx_slider">key1 index:</label>
    <input type="range" id="key1_idx_slider" min="0" max="10000" value="0" step="1" oninput="updateKey1Display(); fetchAndPlot()" />
    <input type="number" id="key1_idx_display" value="0" min="0" max="10000" step="1" style="width: 60px;" onchange="syncSliderWithInput(); fetchAndPlot()" />
    <button onclick="fetchAndPlot()">Plot</button>
    <button id="pickModeBtn" onclick="togglePickMode()">Pick Mode: OFF</button>
    <select id="displayMode" onchange="fetchAndPlot()">
      <option value="auto" selected>auto</option>
      <option value="raw">raw</option>
      <option value="denoised">denoised</option>
      <option value="filtered">Ë°®Á§∫: „Éï„Ç£„É´„Çø</option>
    </select>
    <label for="gain">Gain:</label>
    <input type="range" id="gain" min="0.1" max="5" step="0.1" value="1" oninput="onGainChange()" />
    <span id="gain_display">1√ó</span>
    <select id="denoiseScope">
      <option value="display">Ë°®Á§∫„Çª„ÇØ„Ç∑„Éß„É≥</option>
      <option value="all_key1">„Éá„Éº„ÇøÂÖ®‰Ωì</option>
      <option value="common_shot">ÂÖ±ÈÄö„Ç∑„Éß„ÉÉ„Éà</option>
      <option value="common_receiver">ÂÖ±ÈÄö„É¨„Ç∑„Éº„Éê„Éº</option>
    </select>
    <button id="openDenoiseDlgBtn" onclick="openDenoiseSettings()">„Éé„Ç§„Ç∫ÊäëÂà∂„Éë„É©„É°„Éº„ÇøË®≠ÂÆö</button>
    <label class="denoiseParam">mask_ratio:<input type="number" id="mask_ratio" value="0.5" step="0.1" min="0" max="1" style="width:70px;"></label>
    <label class="denoiseParam">noise_std:<input type="number" id="noise_std" value="1" step="0.1" style="width:70px;"></label>
    <label class="denoiseParam">chunk_h:<input type="number" id="chunk_h" value="128" step="1" style="width:70px;"></label>
    <label class="denoiseParam">overlap:<input type="number" id="overlap" value="32" step="1" style="width:70px;"></label>
    <select id="mask_noise_mode" class="denoiseParam">
      <option value="replace" selected>replace</option>
      <option value="add">add</option>
    </select>
    <button id="denoiseBtn" onclick="handleDenoise()">„Éé„Ç§„Ç∫ÊäëÂà∂</button>
    <progress id="denoiseProgress" value="0" max="1" style="display:none; width:150px;"></progress>
    <span id="denoiseProgressText"></span>
    <button id="openBpfDlgBtn" onclick="openBpfSettings()">BPF„Éë„É©„É°„Éº„ÇøË®≠ÂÆö</button>
    <label class="bpfParam">low_hz:<input type="number" id="low_hz" value="5" step="0.1" style="width:70px;"></label>
    <label class="bpfParam">high_hz:<input type="number" id="high_hz" value="60" step="0.1" style="width:70px;"></label>
    <label class="bpfParam">dt:<input type="number" id="dt" value="0.002" step="0.0001" style="width:70px;"></label>
    <label class="bpfParam">taper:<input type="number" id="taper" value="0.1" step="0.1" style="width:70px;"></label>
    <button id="bpfBtn" onclick="handleBandpass()">BPFÔºàË°®Á§∫„Çª„ÇØ„Ç∑„Éß„É≥Ôºâ</button>
    <button id="bpfApplyBtn" onclick="applyBandpassBatch()">BPFÔºàÂÖ®‰Ωì/ÂÖ±ÈÄöÔºâ</button>
    <label for="colormap">Colormap:</label>
    <select id="colormap" onchange="onColormapChange()">
      <option value="Greys">Greys</option>
      <option value="RdBu">RdBu</option>
      <option value="BWR">BWR</option>
      <option value="Cividis">Cividis</option>
      <option value="Viridis">Viridis</option>
    </select>
    <label><input type="checkbox" id="cmReverse" onchange="onColormapChange()">reverse</label>
  </div>
  <div id="plot" style="width: 100vw; height: calc(100vh - 100px);"></div>
  <dialog id="denoiseSettingsDialog">
    <form method="dialog">
      <label>mask_ratio:<input type="number" id="dlg_mask_ratio" required step="0.1" min="0" max="1"></label>
      <label>noise_std:<input type="number" id="dlg_noise_std" required step="0.1"></label>
      <label>chunk_h:<input type="number" id="dlg_chunk_h" required step="1"></label>
      <label>overlap:<input type="number" id="dlg_overlap" required step="1"></label>
      <label>mask_noise_mode:
        <select id="dlg_mask_noise_mode" required>
          <option value="replace">replace</option>
          <option value="add">add</option>
        </select>
      </label>
      <div style="margin-top:1em;text-align:right;">
        <button type="button" onclick="saveDenoiseSettings()">‰øùÂ≠ò</button>
        <button type="button" onclick="closeDenoiseSettings()">„Ç≠„É£„É≥„Çª„É´</button>
      </div>
    </form>
  </dialog>
  <dialog id="bpfSettingsDialog">
    <form method="dialog">
      <label>low_hz:<input type="number" id="dlg_low_hz" required step="0.1"></label>
      <label>high_hz:<input type="number" id="dlg_high_hz" required step="0.1"></label>
      <label>dt:<input type="number" id="dlg_dt" required step="0.0001"></label>
      <label>taper:<input type="number" id="dlg_taper" required step="0.1"></label>
      <div style="margin-top:1em;text-align:right;">
        <button type="button" onclick="saveBpfSettings()">‰øùÂ≠ò</button>
        <button type="button" onclick="closeBpfSettings()">„Ç≠„É£„É≥„Çª„É´</button>
      </div>
    </form>
  </dialog>
  <script src="/static/plotly-2.29.1.min.js"></script>
  <script src="/static/pako.min.js"></script>
  <script src="/static/msgpack.min.js"></script>
  <script>
    let key1Values = [];
    let currentFileId = '';
    let currentKey1Byte = 189;
    let currentKey2Byte = 193;
    let savedXRange = null;
    let savedYRange = null;
    let latestSeismicData = null;
    const defaultDt = 0.002;
    const PREFETCH_WIDTH = 3;   // ¬±10
    const FALLBACK_MAX = 8;  // API ÁÑ°„ÅÑÂ†¥Âêà
    const HARD_LIMIT_BYTES = 512 * 1024 * 1024; // 512MB

    const cache = new Map(); // key -> { f32: Float32Array }
    const inflight = new Map();
    const CACHE_LIMIT = 12;
    function cacheKey(val, mode) { return `${val}|${mode}`; }
    let sectionShape = null;
    let renderedStart = null;
    let renderedEnd = null;
    let picks = [];
    let downsampleFactor = 1;
    let isPickMode = false;
    let linePickStart = null;
    let deleteRangeStart = null;
    const COLORMAPS = {
      Greys: 'Greys',
      RdBu: 'RdBu',
      BWR: [[0, 'blue'], [0.5, 'white'], [1, 'red']],
      Cividis: 'Cividis',
      Viridis: 'Viridis',
    };

    (function() {
      const saved = localStorage.getItem('denoise_params');
      if (saved) {
        try {
          const p = JSON.parse(saved);
          if (p.mask_ratio !== undefined) document.getElementById('mask_ratio').value = p.mask_ratio;
          if (p.noise_std !== undefined) document.getElementById('noise_std').value = p.noise_std;
          if (p.chunk_h !== undefined) document.getElementById('chunk_h').value = p.chunk_h;
          if (p.overlap !== undefined) document.getElementById('overlap').value = p.overlap;
          if (p.mask_noise_mode !== undefined) document.getElementById('mask_noise_mode').value = p.mask_noise_mode;
        } catch(e){}
      }
    })();

    (function() {
      const saved = localStorage.getItem('bpf_params');
      if (saved) {
        try {
          const p = JSON.parse(saved);
          if (p.low_hz !== undefined) document.getElementById('low_hz').value = p.low_hz;
          if (p.high_hz !== undefined) document.getElementById('high_hz').value = p.high_hz;
          if (p.dt !== undefined) document.getElementById('dt').value = p.dt;
          if (p.taper !== undefined) document.getElementById('taper').value = p.taper;
        } catch(e){}
      }
    })();

    (function() {
      const saved = localStorage.getItem('gain');
      const el = document.getElementById('gain');
      const disp = document.getElementById('gain_display');
      if (el && disp) {
        const val = saved !== null ? parseFloat(saved) : parseFloat(el.value);
        el.value = val;
        disp.textContent = `${val}√ó`;
      }
    })();

    (function() {
      const sel = document.getElementById('colormap');
      const chk = document.getElementById('cmReverse');
      if (sel) {
        const saved = localStorage.getItem('colormap');
        if (saved) sel.value = saved;
      }
      if (chk) {
        const savedRev = localStorage.getItem('cmReverse');
        if (savedRev !== null) chk.checked = savedRev === 'true';
      }
    })();

    function getDenoiseParams() {
      return {
        mask_ratio: parseFloat(document.getElementById('mask_ratio').value),
        noise_std: parseFloat(document.getElementById('noise_std').value),
        chunk_h: parseInt(document.getElementById('chunk_h').value),
        overlap: parseInt(document.getElementById('overlap').value),
        mask_noise_mode: document.getElementById('mask_noise_mode').value,
      };
    }

    function getBpfParams() {
      return {
        low_hz: parseFloat(document.getElementById('low_hz').value),
        high_hz: parseFloat(document.getElementById('high_hz').value),
        dt: parseFloat(document.getElementById('dt').value),
        taper: parseFloat(document.getElementById('taper').value),
      };
    }

    function onGainChange() {
      const val = document.getElementById('gain').value;
      document.getElementById('gain_display').textContent = `${parseFloat(val)}√ó`;
      localStorage.setItem('gain', val);
      if (latestSeismicData) {
        plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
      }
    }

    function onColormapChange() {
      const sel = document.getElementById('colormap');
      const chk = document.getElementById('cmReverse');
      if (sel) localStorage.setItem('colormap', sel.value);
      if (chk) localStorage.setItem('cmReverse', chk.checked);
      if (latestSeismicData) {
        plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
      }
    }

    function openDenoiseSettings() {
      document.getElementById('dlg_mask_ratio').value = document.getElementById('mask_ratio').value;
      document.getElementById('dlg_noise_std').value = document.getElementById('noise_std').value;
      document.getElementById('dlg_chunk_h').value = document.getElementById('chunk_h').value;
      document.getElementById('dlg_overlap').value = document.getElementById('overlap').value;
      document.getElementById('dlg_mask_noise_mode').value = document.getElementById('mask_noise_mode').value;
      const dlg = document.getElementById('denoiseSettingsDialog');
      if (dlg.showModal) dlg.showModal(); else dlg.style.display = 'block';
    }

    function closeDenoiseSettings() {
      const dlg = document.getElementById('denoiseSettingsDialog');
      if (dlg.close) dlg.close(); else dlg.style.display = 'none';
    }

    function saveDenoiseSettings() {
      document.getElementById('mask_ratio').value = document.getElementById('dlg_mask_ratio').value;
      document.getElementById('noise_std').value = document.getElementById('dlg_noise_std').value;
      document.getElementById('chunk_h').value = document.getElementById('dlg_chunk_h').value;
      document.getElementById('overlap').value = document.getElementById('dlg_overlap').value;
      document.getElementById('mask_noise_mode').value = document.getElementById('dlg_mask_noise_mode').value;
      localStorage.setItem('denoise_params', JSON.stringify(getDenoiseParams()));
      closeDenoiseSettings();
      if (typeof fetchAndPlot === 'function') {
        try { fetchAndPlot(); } catch (e) {}
      }
    }

    function openBpfSettings() {
      document.getElementById('dlg_low_hz').value = document.getElementById('low_hz').value;
      document.getElementById('dlg_high_hz').value = document.getElementById('high_hz').value;
      document.getElementById('dlg_dt').value = document.getElementById('dt').value;
      document.getElementById('dlg_taper').value = document.getElementById('taper').value;
      const dlg = document.getElementById('bpfSettingsDialog');
      if (dlg.showModal) dlg.showModal(); else dlg.style.display = 'block';
    }

    function closeBpfSettings() {
      const dlg = document.getElementById('bpfSettingsDialog');
      if (dlg.close) dlg.close(); else dlg.style.display = 'none';
    }

    function saveBpfSettings() {
      document.getElementById('low_hz').value = document.getElementById('dlg_low_hz').value;
      document.getElementById('high_hz').value = document.getElementById('dlg_high_hz').value;
      document.getElementById('dt').value = document.getElementById('dlg_dt').value;
      document.getElementById('taper').value = document.getElementById('dlg_taper').value;
      localStorage.setItem('bpf_params', JSON.stringify(getBpfParams()));
      closeBpfSettings();
      if (typeof fetchAndPlot === 'function') {
        try { fetchAndPlot(); } catch (e) {}
      }
    }

    async function pollDenoiseJob(jobId) {
      const bar = document.getElementById('denoiseProgress');
      const txt = document.getElementById('denoiseProgressText');
      bar.style.display = 'inline-block';
      bar.value = 0;
      txt.textContent = '0%';
      const timer = setInterval(async () => {
        const res = await fetch(`/denoise_job_status?job_id=${jobId}`);
        if (!res.ok) return;
        const data = await res.json();
        bar.value = data.progress;
        txt.textContent = `${Math.round(data.progress * 100)}%`;
        if (data.status === 'done') {
          clearInterval(timer);
          cache.clear();
          await fetchAndPlot();
          setTimeout(() => {
            bar.style.display = 'none';
            txt.textContent = '';
          }, 1000);
        } else if (data.status === 'error') {
          clearInterval(timer);
          txt.textContent = `error`;
        }
      }, 1000);
    }

    async function pollBpfJob(jobId) {
      const bar = document.getElementById('denoiseProgress');
      const txt = document.getElementById('denoiseProgressText');
      bar.style.display = 'inline-block';
      bar.value = 0;
      txt.textContent = 'BPF 0%';
      const timer = setInterval(async () => {
        const res = await fetch(`/bandpass_job_status?job_id=${jobId}`);
        if (!res.ok) return;
        const data = await res.json();
        bar.value = data.progress;
        txt.textContent = `BPF ${Math.round(data.progress * 100)}%`;
        if (data.status === 'done') {
          clearInterval(timer);
          cache.clear();
          await fetchAndPlot();
          setTimeout(() => {
            bar.style.display = 'none';
            txt.textContent = '';
          }, 1000);
        } else if (data.status === 'error') {
          clearInterval(timer);
          txt.textContent = 'BPF error';
        }
      }, 1000);
    }

    async function handleDenoise() {
      const scope = document.getElementById('denoiseScope').value;
      const params = getDenoiseParams();
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      if (scope === 'display') {
        const body = {
          file_id: currentFileId,
          key1_idx: key1Val,
          key1_byte: currentKey1Byte,
          key2_byte: currentKey2Byte,
          ...params,
        };
        const res = await fetch('/denoise_section_bin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        if (!res.ok) {
          alert('denoise failed');
          return;
        }
        const bin = new Uint8Array(await res.arrayBuffer());
        const obj = msgpack.decode(bin);
        const int8 = new Int8Array(obj.data.buffer);
        const f32  = Float32Array.from(int8, v => v / obj.scale);
        putCacheF32(cacheKey(key1Val, 'den'), f32);
        sectionShape = obj.shape;
        await fetchAndPlot();
      } else {
        const body = {
          file_id: currentFileId,
          scope: scope === 'all_key1' ? 'all_key1' : 'by_header',
          key1_byte: currentKey1Byte,
          key2_byte: currentKey2Byte,
          ...params,
        };
        if (scope !== 'all_key1') {
          body.key1_idx = key1Val;
          body.group_header_byte =
            scope === 'common_shot' ? currentKey1Byte : currentKey2Byte;
        }
        const res = await fetch('/denoise_apply', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        if (!res.ok) {
          alert('denoise apply failed');
          return;
        }
        const data = await res.json();
        pollDenoiseJob(data.job_id);
      }
    }

    async function handleBandpass() {
      const params = getBpfParams();
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      const body = {
        file_id: currentFileId,
        key1_idx: key1Val,
        key1_byte: currentKey1Byte,
        key2_byte: currentKey2Byte,
        ...params,
      };
      const res = await fetch('/bandpass_section_bin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!res.ok) {
        alert('bandpass failed');
        return;
      }
      const bin = new Uint8Array(await res.arrayBuffer());
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      const f32  = Float32Array.from(int8, v => v / obj.scale);
      putCacheF32(cacheKey(key1Val, 'filt'), f32);
      sectionShape = obj.shape;
      await fetchAndPlot();
    }

    async function applyBandpassBatch() {
      const scope = document.getElementById('denoiseScope').value;
      const params = getBpfParams();
      const index = parseInt(document.getElementById('key1_idx_slider').value);
      const key1Val = key1Values[index];
      if (scope === 'display') {
        await handleBandpass();
      } else {
        const body = {
          file_id: currentFileId,
          scope: scope === 'all_key1' ? 'all_key1' : 'by_header',
          key1_byte: currentKey1Byte,
          key2_byte: currentKey2Byte,
          ...params,
        };
        if (scope !== 'all_key1') {
          body.key1_idx = key1Val;
          body.group_header_byte =
            scope === 'common_shot' ? currentKey1Byte : currentKey2Byte;
        }
        const res = await fetch('/bandpass_apply', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        if (!res.ok) {
          alert('bandpass apply failed');
          return;
        }
        const data = await res.json();
        pollBpfJob(data.job_id);
      }
    }

    function togglePickMode() {
      isPickMode = !isPickMode;
      const btn = document.getElementById('pickModeBtn');
      btn.textContent = isPickMode ? 'Pick Mode: ON' : 'Pick Mode: OFF';
      btn.classList.toggle('active', isPickMode);
      linePickStart = null;
      deleteRangeStart = null;
      if (latestSeismicData) {
        plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
      }
    }

  function putCacheF32(key, f32) {
    if (cache.size >= CACHE_LIMIT) {
      const oldestKey = cache.keys().next().value;
      const old = cache.get(oldestKey);
      if (old) old.f32 = null;
      cache.delete(oldestKey);
    }
    cache.set(key, { f32 });

    const canCheckMemory =
      performance.memory &&
      performance.memory.usedJSHeapSize > 0;

    const used = canCheckMemory ? performance.memory.usedJSHeapSize : 0;

    console.log('--- putCache called ---');
    console.log('Added key:', cache.keys());
    console.log('Cache size:', cache.size);
    if (canCheckMemory) {
      const total = performance.memory.totalJSHeapSize;
      const ratio = used / total;
      console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB`);

    } else {
      console.log(`used: ${(used / 1024 / 1024).toFixed(2)} MB (fallback, no total)`);
    }

    if (used > HARD_LIMIT_BYTES) {
      console.warn(`‚ö† Memory limit exceeded! (${(used / 1024 / 1024).toFixed(1)} MB > 512 MB)`);
      let removed = 0;
      while (cache.size > 1) {
        const removedKey = cache.keys().next().value;
        const entry = cache.get(removedKey);

        // üîΩ „É°„É¢„É™Ëß£Êîæ„Çí‰øÉ„Åô„Åü„ÇÅ„Å´ÂèÇÁÖß„ÇíÂàá„Çã
        if (entry) {
          entry.f32 = null;
        }

        cache.delete(removedKey);
        removed++;
      }
      console.warn(`Evicted ${removed} items due to hard heap limit.`);
      console.log('Remaining keys:', Array.from(cache.keys()));
    }

    console.log('------------------------');
  }
    function getCacheF32(key) {
      if (!cache.has(key)) return null;
      const entry = cache.get(key);
      cache.delete(key); cache.set(key, entry); // refresh LRU
      return entry;
    }

    function updateKey1Display() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const idx = parseInt(slider.value);
      display.value = key1Values[idx] ?? '';
    }

    function syncSliderWithInput() {
      const slider = document.getElementById('key1_idx_slider');
      const display = document.getElementById('key1_idx_display');
      const val = parseInt(display.value);
      const idx = key1Values.indexOf(val);
      slider.value = idx >= 0 ? idx : 0;
      display.value = key1Values[slider.value] ?? '';
    }

    function stepKey1(delta) {
      const slider = document.getElementById('key1_idx_slider');
      let value = parseInt(slider.value) + delta;
      value = Math.max(slider.min, Math.min(slider.max, value));
      slider.value = value;
      updateKey1Display();
    }

    function setKey1SliderMax(max) {
      document.getElementById('key1_idx_slider').max = max;
    }

      async function fetchKey1Values() {
        const res = await fetch(`/get_key1_values?file_id=${currentFileId}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`);
        if (res.ok) {
          const data = await res.json();
          key1Values = data.values;
          setKey1SliderMax(key1Values.length - 1);
          document.getElementById('key1_idx_display').min = key1Values[0];
          document.getElementById('key1_idx_display').max = key1Values[key1Values.length - 1];
          document.getElementById('key1_idx_slider').value = 0;
          updateKey1Display();
        }
      }

      function prefetchAround(centerIdx, mode) {
        if (mode === 'denoised') return;
        for (const ctrl of inflight.values()) ctrl.abort();
        inflight.clear();
        const start = Math.max(0, centerIdx - PREFETCH_WIDTH);
        const end = Math.min(key1Values.length - 1, centerIdx + PREFETCH_WIDTH);
        const scheduler = cb => {
          if ('requestIdleCallback' in window) {
            requestIdleCallback(cb);
          } else {
            setTimeout(cb, 0);
          }
        };
        for (let i = start; i <= end; i++) {
          if (i === centerIdx) continue;
          const key1Val = key1Values[i];
          if (mode === 'auto') {
            if (cache.has(cacheKey(key1Val, 'den')) || cache.has(cacheKey(key1Val, 'filt')) || cache.has(cacheKey(key1Val, 'raw')) ||
                inflight.has(cacheKey(key1Val, 'den')) || inflight.has(cacheKey(key1Val, 'filt')) || inflight.has(cacheKey(key1Val, 'raw'))) continue;
          } else {
            const ck = cacheKey(key1Val, mode === 'denoised' ? 'den' : mode === 'filtered' ? 'filt' : 'raw');
            if (cache.has(ck) || inflight.has(ck)) continue;
          }
          const controller = new AbortController();
          const inflightKey = mode === 'raw' ? cacheKey(key1Val, 'raw') :
                              mode === 'denoised' ? cacheKey(key1Val, 'den') :
                              mode === 'filtered' ? cacheKey(key1Val, 'filt') :
                              cacheKey(key1Val, 'den');
          inflight.set(inflightKey, controller);
          scheduler(async () => {
            try {
              const denoiseParams = getDenoiseParams();
              const bpfParams = getBpfParams();
              const urlDen = `/get_denoised_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&chunk_h=${denoiseParams.chunk_h}&overlap=${denoiseParams.overlap}&mask_ratio=${denoiseParams.mask_ratio}&noise_std=${denoiseParams.noise_std}&mask_noise_mode=${denoiseParams.mask_noise_mode}`;
              const urlFilt = `/get_bandpassed_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&low_hz=${bpfParams.low_hz}&high_hz=${bpfParams.high_hz}&dt=${bpfParams.dt}&taper=${bpfParams.taper}`;
              const urlRaw = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
              let res;
              let fetchedMode = 'raw';
              if (mode === 'raw') {
                res = await fetch(urlRaw, { signal: controller.signal });
                if (!res.ok) return;
              } else if (mode === 'denoised') {
                res = await fetch(urlDen, { signal: controller.signal });
                if (res.ok) {
                  fetchedMode = 'den';
                } else {
                  res = await fetch(urlRaw, { signal: controller.signal });
                  if (!res.ok) return;
                }
              } else if (mode === 'filtered') {
                res = await fetch(urlFilt, { signal: controller.signal });
                if (res.ok) {
                  fetchedMode = 'filt';
                } else {
                  res = await fetch(urlRaw, { signal: controller.signal });
                  if (!res.ok) return;
                }
              } else {
                res = await fetch(urlDen, { signal: controller.signal });
                if (res.ok) {
                  fetchedMode = 'den';
                } else {
                  res = await fetch(urlFilt, { signal: controller.signal });
                  if (res.ok) {
                    fetchedMode = 'filt';
                  } else {
                    res = await fetch(urlRaw, { signal: controller.signal });
                    if (!res.ok) return;
                  }
                }
              }
              const bin = new Uint8Array(await res.arrayBuffer());
              const obj = msgpack.decode(bin);
              const int8 = new Int8Array(obj.data.buffer);
              const f32  = Float32Array.from(int8, v => v / obj.scale);
              putCacheF32(cacheKey(key1Val, fetchedMode), f32);
              if (!sectionShape) sectionShape = obj.shape;
            } catch (err) {
              if (err.name !== 'AbortError') {
                console.warn('Prefetch failed', key1Val, err);
              }
            } finally {
              inflight.delete(inflightKey);
            }
          });
        }
      }

    async function loadSettings() {
      const params = new URLSearchParams(window.location.search);
      currentFileId = params.get('file_id') || localStorage.getItem('file_id') || '';
      currentKey1Byte = parseInt(params.get('key1_byte') || localStorage.getItem('key1_byte') || '189');
      currentKey2Byte = parseInt(params.get('key2_byte') || localStorage.getItem('key2_byte') || '193');
      document.getElementById('file_id').value = currentFileId;
      if (currentFileId) {
        localStorage.setItem('file_id', currentFileId);
        localStorage.setItem('key1_byte', currentKey1Byte);
        localStorage.setItem('key2_byte', currentKey2Byte);
        await fetchKey1Values();
        await fetchPicks();
        await fetchAndPlot();
      }
    }

  async function fetchPicks() {
    if (!currentFileId) return;
    const idx = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[idx];
    try {
      const res = await fetch(`/picks?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`);
      if (res.ok) {
        const data = await res.json();
        picks = (data.picks || []).map(p => ({ trace: p.trace, time: p.time }));
      }
    } catch (e) {
      console.error('Failed to fetch picks', e);
    }
  }

  async function postPick(trace, time) {
    const idx = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[idx];
    try {
      await fetch('/picks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ file_id: currentFileId, trace, time, key1_idx: key1Val, key1_byte: currentKey1Byte })
      });
    } catch (e) {
      console.error('Failed to post pick', e);
    }
  }

  async function deletePick(trace) {
    const idx = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[idx];
    try {
      await fetch(`/picks?file_id=${currentFileId}&trace=${trace}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}`, { method: 'DELETE' });
    } catch (e) {
      console.error('Failed to delete pick', e);
    }
  }

  async function fetchAndPlot() {
    console.log('--- fetchAndPlot start ---');
    console.time('Total fetchAndPlot');

    const mode = document.getElementById('displayMode').value;
    const index = parseInt(document.getElementById('key1_idx_slider').value);
    const key1Val = key1Values[index];

    await fetchPicks();

    console.time('Cache lookup');
    let hit = null;
    if (mode === 'raw') {
      hit = getCacheF32(cacheKey(key1Val, 'raw'));
    } else if (mode === 'denoised') {
      hit = getCacheF32(cacheKey(key1Val, 'den'));
    } else if (mode === 'filtered') {
      hit = getCacheF32(cacheKey(key1Val, 'filt'));
    } else {
      hit = getCacheF32(cacheKey(key1Val, 'den')) ||
            getCacheF32(cacheKey(key1Val, 'filt')) ||
            getCacheF32(cacheKey(key1Val, 'raw'));
    }
    console.timeEnd('Cache lookup');

    let traces;
    let f32 = hit ? hit.f32 : null;

    if (f32) {
      console.time('Decode from cache');
      const [nTraces, nSamples] = sectionShape;
      traces = new Array(nTraces);
      for (let i = 0; i < nTraces; i++) {
        traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
      }
      console.timeEnd('Decode from cache');
      latestSeismicData = traces;
    } else {
      console.time('Fetch binary');
      const denoiseParams = getDenoiseParams();
      const bpfParams = getBpfParams();
      const urlDen = `/get_denoised_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&chunk_h=${denoiseParams.chunk_h}&overlap=${denoiseParams.overlap}&mask_ratio=${denoiseParams.mask_ratio}&noise_std=${denoiseParams.noise_std}&mask_noise_mode=${denoiseParams.mask_noise_mode}`;
      const urlFilt = `/get_bandpassed_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&low_hz=${bpfParams.low_hz}&high_hz=${bpfParams.high_hz}&dt=${bpfParams.dt}&taper=${bpfParams.taper}`;
      const urlRaw = `/get_section_bin?file_id=${currentFileId}&key1_idx=${key1Val}&key1_byte=${currentKey1Byte}&key2_byte=${currentKey2Byte}`;
      let res;
      let fetchedMode = 'raw';
      if (mode === 'raw') {
        res = await fetch(urlRaw);
        if (!res.ok) {
          console.timeEnd('Fetch binary');
          alert('Failed to load section');
          return;
        }
      } else if (mode === 'denoised') {
        res = await fetch(urlDen);
        if (res.ok) {
          fetchedMode = 'den';
        } else {
          alert('denoised section not available, showing raw');
          res = await fetch(urlRaw);
          if (!res.ok) {
            console.timeEnd('Fetch binary');
            alert('Failed to load section');
            return;
          }
        }
      } else if (mode === 'filtered') {
        res = await fetch(urlFilt);
        if (res.ok) {
          fetchedMode = 'filt';
        } else {
          res = await fetch(urlRaw);
          if (!res.ok) {
            console.timeEnd('Fetch binary');
            alert('Failed to load section');
            return;
          }
        }
      } else {
        res = await fetch(urlDen);
        if (res.ok) {
          fetchedMode = 'den';
        } else {
          res = await fetch(urlFilt);
          if (res.ok) {
            fetchedMode = 'filt';
          } else {
            res = await fetch(urlRaw);
            if (!res.ok) {
              console.timeEnd('Fetch binary');
              alert('Failed to load section');
              return;
            }
          }
        }
      }
      const bin = new Uint8Array(await res.arrayBuffer());
      console.timeEnd('Fetch binary');

      console.time('Decode & cache');
      const obj = msgpack.decode(bin);
      const int8 = new Int8Array(obj.data.buffer);
      f32 = Float32Array.from(int8, v => v / obj.scale);
      putCacheF32(cacheKey(key1Val, fetchedMode), f32);
      sectionShape = obj.shape;
      const [nTraces, nSamples] = sectionShape;
      traces = new Array(nTraces);
      for (let i = 0; i < nTraces; i++) {
        traces[i] = f32.subarray(i * nSamples, (i + 1) * nSamples);
      }
      console.timeEnd('Decode & cache');
      latestSeismicData = traces;
    }

    console.time('Plotting');
    const [s, e] = savedXRange ? visibleTraceIndices(savedXRange, latestSeismicData.length) : [0, latestSeismicData.length - 1];
    plotSeismicData(latestSeismicData, defaultDt, s, e);
    console.timeEnd('Plotting');

    console.time('Prefetch');
    prefetchAround(index, mode);
    console.timeEnd('Prefetch');

    console.timeEnd('Total fetchAndPlot');
    console.log('--- fetchAndPlot end ---');
  }

    function visibleTraceIndices(range, total) {
      let start = Math.floor(range[0]);
      let end = Math.ceil(range[1]);
      start = Math.max(0, start);
      end = Math.min(total - 1, end);
      return [start, end];
    }

    function plotSeismicData(seismic, dt, startTrace = 0, endTrace = seismic.length - 1) {
      const totalTraces = seismic.length;
      startTrace = Math.max(0, startTrace);
      endTrace = Math.min(totalTraces - 1, endTrace);
      const nTraces = endTrace - startTrace + 1;
      const nSamples = seismic[0].length;
      const plotDiv = document.getElementById('plot');

      const widthPx = plotDiv.clientWidth || 1;
      const xRange = savedXRange ?? [0, totalTraces - 1];
      const visibleTraces = endTrace - startTrace + 1;
      const density = visibleTraces / widthPx;

      let traces = [];
      const gain = parseFloat(document.getElementById('gain').value) || 1.0;

      if (density < 0.1) {
        downsampleFactor = 1;
        const time = new Float32Array(nSamples);
        for (let t = 0; t < nSamples; t++) {
          time[t] = t * dt;
        }
        for (let i = startTrace; i <= endTrace; i++) {
          const raw = seismic[i];
          const baseX = new Float32Array(nSamples);
          const shiftedFullX = new Float32Array(nSamples);
          const shiftedPosX = new Float32Array(nSamples);
          for (let j = 0; j < nSamples; j++) {
            const val = raw[j] * gain;
            baseX[j] = i;
            shiftedFullX[j] = val + i;
            shiftedPosX[j] = (val < 0 ? 0 : val) + i;
          }

          traces.push({ type: 'scatter', mode: 'lines', x: baseX, y: time, line: { width: 0 }, hoverinfo: 'x+y', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedPosX, y: time, fill: 'tonextx', fillcolor: 'black', line: { width: 0 }, opacity: 0.6, hoverinfo: 'skip', showlegend: false });
          traces.push({ type: 'scatter', mode: 'lines', x: shiftedFullX, y: time, line: { color: 'black', width: 0.5 }, hoverinfo: 'skip',showlegend: false });
        }
      } else {
        const MAX_POINTS = 3_000_000;
        let factor = 1;
        while (Math.floor(nTraces / factor) * Math.floor(nSamples / factor) > MAX_POINTS) {
          factor++;
        }

        const nTracesDS = Math.floor(nTraces / factor);
        const nSamplesDS = Math.floor(nSamples / factor);
        console.log('Downsampling factor:', factor);
        console.log('Final dimensions:', nTracesDS, 'x', nSamplesDS);

        const time = new Float32Array(nSamplesDS);
        for (let t = 0; t < nSamplesDS; t++) {
          time[t] = t * dt * factor;
        }

        const zData = Array.from({ length: nSamplesDS }, () => new Float32Array(nTracesDS));
        // „Ç´„É©„Éº„Çπ„Ç±„Éº„É´„ÅØ„Ç≤„Ç§„É≥Ââç„ÅÆÂÄ§„ÅßÂõ∫ÂÆö„Åô„ÇãÔºàËá™Â∑±Ê≠£Ë¶èÂåñ„ÇíÈÅø„Åë„ÇãÔºâ
        let baseMin = Infinity;
        let baseMax = -Infinity;
        for (let i = startTrace, col = 0; col < nTracesDS; i += factor, col++) {
          const trace = seismic[i];
          for (let j = 0, row = 0; row < nSamplesDS; j += factor, row++) {
            const raw = trace[j];
            const val = raw * gain;
            zData[row][col] = val;
            if (raw < baseMin) baseMin = raw;
            if (raw > baseMax) baseMax = raw;
          }
        }
        const xVals = new Float32Array(nTracesDS);
        for (let i = 0; i < nTracesDS; i++) xVals[i] = startTrace + i * factor;
        downsampleFactor = factor;
        const cmName = document.getElementById('colormap')?.value || 'Greys';
        const reverse = document.getElementById('cmReverse')?.checked || false;
        const cm = COLORMAPS[cmName] || 'Greys';
        const isDiv = cmName === 'RdBu' || cmName === 'BWR';
        traces = [{
          type: 'heatmap',
          x: xVals,
          y: time,
          z: zData,
          colorscale: cm,
          reversescale: reverse,
          // „Ç≤„Ç§„É≥Ââç„ÅÆ„Éô„Éº„ÇπÁØÑÂõ≤„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„ÄÅ„Ç≤„Ç§„É≥Â§âÊõ¥„ÅåÂèØË¶ñÁöÑ„Å™„Ç≥„É≥„Éà„É©„Çπ„ÉàÂ§âÂåñ„Å´„Å™„Çã
          zmin: baseMin,
          zmax: baseMax,
          ...(isDiv ? { zmid: 0 } : {}),
          showscale: false,
          hoverinfo: 'x+y',
          hovertemplate: '',
        }];
      }

      const layout = {
        xaxis: {
          title: 'Trace',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: !savedXRange,
          ...(savedXRange ? { range: savedXRange } : {})
        },
        yaxis: {
          title: 'Time (s)',
          showgrid: false,
          tickfont: { color: '#000' },
          titlefont: { color: '#000' },
          autorange: false,
          range: savedYRange ?? [nSamples * dt, 0]  // reversed „ÇíÊâãÂãïË®≠ÂÆö
        },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        margin: { t: 10, r: 10, l: 60, b: 40 },
        dragmode: isPickMode ? false : 'zoom'
      };
        layout.shapes = picks.map(p => ({
          type: 'line',
          x0: p.trace - 0.4,
          x1: p.trace + 0.4,
          y0: p.time,
          y1: p.time,
          line: { color: 'red', width: 2 }
        }));

      Plotly.react(plotDiv, traces, layout, {
        responsive: true,
        editable: true,
        modeBarButtonsToAdd: ['eraseshape'],
        edits: { shapePosition: false }
      });
      setTimeout(() => Plotly.Plots.resize(plotDiv), 50);
      renderedStart = startTrace;
      renderedEnd = endTrace;
      console.log(`Rendered traces ${startTrace}-${endTrace}`);

      plotDiv.removeAllListeners('plotly_relayout');
      plotDiv.removeAllListeners('plotly_click');
      plotDiv.on('plotly_relayout', handleRelayout);
      if (isPickMode) {
        plotDiv.on('plotly_click', handlePlotClick);
      }
    }

      function pickOnTrace(trace) {
        return picks.findIndex(p => Math.round(p.trace) === trace);
      }

    async function handlePlotClick(ev) {
      if (!isPickMode) return;
      console.log('üî• plotly_click fired', ev);
      const plotDiv = document.getElementById('plot');
      if (!plotDiv || !ev.event || !ev.event.clientX) {
        console.warn('‚ö†Ô∏è plotDiv or event data not available.');
        return;
      }

      const dt = defaultDt * downsampleFactor;

      // -------- „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„ÇíÂèñÂæó„Åó„ÄÅËª∏Â∫ßÊ®ô„Å´Â§âÊèõ --------
      const rect = plotDiv.getBoundingClientRect();
      const xpx = ev.event.clientX - rect.left;
      const ypx = ev.event.clientY - rect.top;

      const xData = plotDiv._fullLayout.xaxis.p2d(xpx);
      const yData = plotDiv._fullLayout.yaxis.p2d(ypx);

      // -------- trace / time „ÇíÊï¥Êï∞„Ç∞„É™„ÉÉ„Éâ„Å´„Çπ„Éä„ÉÉ„Éó --------
      const trace = Math.round(ev.points[0].x);
      const time = Math.round(ev.points[0].y / dt) * dt;

      // -------- „É≠„Ç∞ --------
      console.group('üñ± Actual Click Data');
      console.log('clientX / Y:', ev.event.clientX, ev.event.clientY);
      console.log('pixel offset:', xpx, ypx);
      console.log('xData (trace):', xData);
      console.log('yData (time):', yData);
      console.log('Snapped trace:', trace);
      console.log('Snapped time:', time);
      console.groupEnd();

        // -------- Ctrl+„ÇØ„É™„ÉÉ„ÇØ„ÅßÁØÑÂõ≤ÂâäÈô§ --------
        if (ev.event.ctrlKey) {
          if (deleteRangeStart === null) {
            deleteRangeStart = trace;
            linePickStart = null;
            return;
          }
          const x0 = deleteRangeStart;
          deleteRangeStart = null;
          const x1 = trace;
          const start = Math.min(x0, x1);
          const end = Math.max(x0, x1);
          const toDelete = picks.filter(p => Math.round(p.trace) >= start && Math.round(p.trace) <= end);
          const promises = toDelete.map(p => deletePick(Math.round(p.trace)));
          picks = picks.filter(p => Math.round(p.trace) < start || Math.round(p.trace) > end);
          await Promise.all(promises);
          plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
          return;
        }

        // -------- Shift+„ÇØ„É™„ÉÉ„ÇØ„Åß„É©„Ç§„É≥„Éî„ÉÉ„ÇØ --------
        if (ev.event.shiftKey) {
          if (!linePickStart) {
            linePickStart = { trace, time };
            deleteRangeStart = null;
            return;
          }

          const { trace: x0, time: y0 } = linePickStart;
          linePickStart =  { trace, time };
          const x1 = trace;
          const y1 = time;
          const xStart = Math.round(Math.min(x0, x1));
          const xEnd = Math.round(Math.max(x0, x1));
          const slope = x1 === x0 ? 0 : (y1 - y0) / (x1 - x0);
          const promises = [];
          for (let x = xStart; x <= xEnd; x++) {
            const y = x1 === x0 ? y1 : y0 + slope * (x - x0);
            const snapped = Math.round(y / dt) * dt;
            const idx = pickOnTrace(x);
            if (idx >= 0) {
              promises.push(deletePick(x));
              picks.splice(idx, 1);
            }
            picks.push({ trace: x, time: snapped });
            promises.push(postPick(x, snapped));
          }
          await Promise.all(promises);
          plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
          return;
        }

        // -------- ÈÄöÂ∏∏„ÇØ„É™„ÉÉ„ÇØ„ÅßÂçò‰∏Ä„Éî„ÉÉ„ÇØ --------
        linePickStart = null;
        deleteRangeStart = null;
        const idx = pickOnTrace(trace);
        const promises = [];
        if (idx >= 0) {
          promises.push(deletePick(trace));
          picks.splice(idx, 1);
        }
        picks.push({ trace, time });
        promises.push(postPick(trace, time));
        await Promise.all(promises);
        plotSeismicData(latestSeismicData, defaultDt, renderedStart, renderedEnd);
      }

    async function handleRelayout(ev) {
      const plotDiv = document.getElementById('plot');
      if ('xaxis.range[0]' in ev && 'xaxis.range[1]' in ev) {
        savedXRange = [ev['xaxis.range[0]'], ev['xaxis.range[1]']];
      } else if ('xaxis.autorange' in ev && ev['xaxis.autorange'] === true) {
        savedXRange = null;
        savedYRange = null;
      }

      if ('yaxis.range[0]' in ev && 'yaxis.range[1]' in ev) {
        const y0 = ev['yaxis.range[0]'];
        const y1 = ev['yaxis.range[1]'];
        savedYRange = y0 > y1 ? [y0, y1] : [y1, y0];
      }

      if (latestSeismicData) {
        const [s, e] = savedXRange
          ? visibleTraceIndices(savedXRange, latestSeismicData.length)
          : [0, latestSeismicData.length - 1];
        if (s !== renderedStart || e !== renderedEnd) {
          plotSeismicData(latestSeismicData, defaultDt, s, e);
        }
      }

      if (Array.isArray(ev.shapes)) {
        const newPicks = ev.shapes.map(s => ({ trace: (s.x0 + s.x1) / 2, time: (s.y0 + s.y1) / 2 }));
        const oldTraces = new Set(picks.map(p => Math.round(p.trace)));
        const newTraces = new Set(newPicks.map(p => Math.round(p.trace)));
        for (const t of oldTraces) {
          if (!newTraces.has(t)) {
            await deletePick(t);
          }
        }
        picks = newPicks;
      }
    }

    window.addEventListener('DOMContentLoaded', loadSettings);

    // Toggle between raw and denoised displays with the "n" key
    window.addEventListener('keydown', (e) => {
        if (
          e.key.toLowerCase() === 'n' &&
          !e.ctrlKey &&
          !e.altKey &&
          !e.metaKey &&
          !['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)
        ) {
          const sel = document.getElementById('displayMode');
          sel.value = sel.value === 'denoised' ? 'raw' : 'denoised';
          fetchAndPlot();
        }
      });

    window.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
          linePickStart = null;
        }
      });
  </script>
</body>
</html>
